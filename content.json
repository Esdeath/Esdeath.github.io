{"meta":{"title":"Hexo","subtitle":"","description":"","author":"驿路星辰","url":"https://github.com/Esdeath/Esdeath.github.io","root":"/"},"pages":[],"posts":[{"title":"Flutter中针对iOS封装Plugin组件注意事项","slug":"flutter-ios-plugin-delegate-error","date":"2020-08-29T01:10:14.000Z","updated":"2022-05-06T08:08:46.409Z","comments":true,"path":"2020/08/29/flutter-ios-plugin-delegate-error/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/08/29/flutter-ios-plugin-delegate-error/","excerpt":"","text":"封装Plugin组件注意事项问题类型:https://github.com/flutter/flutter/issues/74024iOS组件可能要用到appdelegate中的相关的回调方法。此时针对具有bool返回值会有的回调方法会有问题: 如果返回YES ,则先调用的组件会导致后调用的组件相同的回调方法无法执行 如果返回NO,在冷启动的时候,回调方法不会被吊起。 处理方法可以通过统一返回FlutterPluginAppLifeCycleDelegate调用方法来处理 1.声明FlutterPluginAppLifeCycleDelegate 123456@interface YochatsharePlugin()@property FlutterMethodChannel *methodChannel;@property (nonatomic, strong) NSMutableDictionary *shareDataSource;@property (nonatomic, strong) FlutterPluginAppLifeCycleDelegate* lifeCycleDelegate;@end 2.初始化FlutterPluginAppLifeCycleDelegate 123456- (instancetype)init &#123; if (self = [super init]) &#123; _lifeCycleDelegate = [[FlutterPluginAppLifeCycleDelegate alloc] init]; &#125; return self;&#125; 3.通过FlutterPluginAppLifeCycleDelegate返回 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary&lt;UIApplicationLaunchOptionsKey,id&gt; *)launchOptions &#123; [MCShareConfig shareInstance].groupId = @\"group.com.atomcloudstudio.splashchat\"; [MCShareConfig shareInstance].containAppScheme = @\"yochatshare://\"; __weak typeof(self) weakSelf = self; if (self.shareDataSource.count == 0) return YES; [self.shareDataSource removeAllObjects]; [self.methodChannel invokeMethod:@\"sendPhoto\" arguments:self.shareDataSource result:^(id _Nullable result) &#123; [weakSelf.shareDataSource removeAllObjects]; [MCShareTool mcs_clearData]; &#125;]; return [_lifeCycleDelegate application:application didFinishLaunchingWithOptions:launchOptions];&#125; 其他所有方法的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@interface AppDelegate ()@property (nonatomic, strong) FlutterPluginAppLifeCycleDelegate* lifeCycleDelegate;@end@implementation AppDelegate- (instancetype)init &#123; if (self = [super init]) &#123; _lifeCycleDelegate = [[FlutterPluginAppLifeCycleDelegate alloc] init]; &#125; return self;&#125;- (BOOL)application:(UIApplication*)applicationdidFinishLaunchingWithOptions:(NSDictionary&lt;UIApplicationLaunchOptionsKey, id&gt;*))launchOptions &#123; self.flutterEngine = [[FlutterEngine alloc] initWithName:@\"messageFlutter\" project:nil]; [self.flutterEngine runWithEntrypoint:nil]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [_lifeCycleDelegate application:application didFinishLaunchingWithOptions:launchOptions];&#125;- (FlutterViewController*)rootFlutterViewController &#123; UIViewController* viewController = [UIApplication sharedApplication].keyWindow.rootViewController; if ([viewController isKindOfClass:[FlutterViewController class]]) &#123; return (FlutterViewController*)viewController; &#125; return nil;&#125;- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event &#123; [super touchesBegan:touches withEvent:event]; if (self.rootFlutterViewController != nil) &#123; [self.rootFlutterViewController handleStatusBarTouches:event]; &#125;&#125;- (void)application:(UIApplication*)applicationdidRegisterUserNotificationSettings:(UIUserNotificationSettings*)notificationSettings &#123; [_lifeCycleDelegate application:applicationdidRegisterUserNotificationSettings:notificationSettings];&#125;- (void)application:(UIApplication*)applicationdidRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken &#123; [_lifeCycleDelegate application:applicationdidRegisterForRemoteNotificationsWithDeviceToken:deviceToken];&#125;- (void)application:(UIApplication*)applicationdidReceiveRemoteNotification:(NSDictionary*)userInfofetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler &#123; [_lifeCycleDelegate application:application didReceiveRemoteNotification:userInfo fetchCompletionHandler:completionHandler];&#125;- (BOOL)application:(UIApplication*)application openURL:(NSURL*)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey, id&gt;*)options &#123; return [_lifeCycleDelegate application:application openURL:url options:options];&#125;- (BOOL)application:(UIApplication*)application handleOpenURL:(NSURL*)url &#123; return [_lifeCycleDelegate application:application handleOpenURL:url];&#125;- (BOOL)application:(UIApplication*)application openURL:(NSURL*)url sourceApplication:(NSString*)sourceApplication annotation:(id)annotation &#123; return [_lifeCycleDelegate application:application openURL:url sourceApplication:sourceApplication annotation:annotation];&#125;- (void)application:(UIApplication*)applicationperformActionForShortcutItem:(UIApplicationShortcutItem*)shortcutItem completionHandler:(void (^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0) &#123; [_lifeCycleDelegate application:application performActionForShortcutItem:shortcutItem completionHandler:completionHandler];&#125;- (void)application:(UIApplication*)applicationhandleEventsForBackgroundURLSession:(nonnull NSString*)identifier completionHandler:(nonnull void (^)(void))completionHandler &#123; [_lifeCycleDelegate application:applicationhandleEventsForBackgroundURLSession:identifier completionHandler:completionHandler];&#125;- (void)application:(UIApplication*)applicationperformFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler &#123; [_lifeCycleDelegate application:application performFetchWithCompletionHandler:completionHandler];&#125;- (void)addApplicationLifeCycleDelegate:(NSObject&lt;FlutterPlugin&gt;*)delegate &#123; [_lifeCycleDelegate addDelegate:delegate];&#125;@end","categories":[],"tags":[]},{"title":"Flutter中使用Provider实现MVVM架构","slug":"flutter-mvvm","date":"2020-08-29T01:10:14.000Z","updated":"2022-05-02T05:51:49.849Z","comments":true,"path":"2020/08/29/flutter-mvvm/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/08/29/flutter-mvvm/","excerpt":"","text":"MVVM介绍MVVM架构分为M(Model)、V(View)、VM(ViewModel)三个部分，他们分别处理自己的分工，在View和Model之间使用ViewModel作为中介者，使View和Model不受业务逻辑影响。 Model: 模型层，处理Api数据、模型相关业务 View: 视图层，UI呈现、使用者互动等。 ViewModel: 视图模型，处理逻辑、将数据绑定给View展示。 Controller: 负责主要事情就是将View和ViewModel进行绑定，生命周期管理 MVVM的核心思想即：通过ViewModel在View和Model之间建立一个连接，实现View和Model的双向绑定。 Flutter中的MVVM应用Flutter中通过Provider进行状态管理，来实现MVVM。在MVVM的原本的三个部分添加Services层，方便业务的分离. Services: 是获取数据接口（服务器Server 或者 本地Store） Model: 主要负责转换模型 View: 主要负责呈现UI，通过ViewModel获取数据并展示 ViewModel: 处理业务逻辑，将数据绑定给View展示 Controller:一般是stf，负责主要事情就是将View和ViewModel进行绑定，生命周期管理 1.定义模型将网络请求回来的数据转换为对应的模型 123456789101112131415161718192021222324class DeviceOnlineStatusData &#123; String deviceId; String deviceType; String loginTime; String createdAt; DeviceOnlineStatusData(&#123;this.deviceId, this.deviceType, this.loginTime, this.createdAt&#125;); DeviceOnlineStatusData.fromJson(Map&lt;String, dynamic&gt; json) &#123; deviceId = json['device_id']; deviceType = json['device_type']; loginTime = json['login_time']; createdAt = json['created_at']; &#125; Map&lt;String, dynamic&gt; toJson() &#123; final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;(); data['device_id'] = this.deviceId; data['device_type'] = this.deviceType; data['login_time'] = this.loginTime; data['created_at'] = this.createdAt; return data; &#125;&#125; 2.定义ViewModel这个ViewModel主要负责把请求回来的数据进行处理，并通知View层更新数据 123456789101112131415161718192021222324252627282930class DeviceOnlineStatusVM extends ChangeNotifier &#123; bool isPcLogin = false; bool isPadLogin = false; String pcDeviceID = ''; String pcDeviceType = ''; String padDeviceID = ''; String padDeviceType = ''; setOnlineStatus(List&lt;DeviceOnlineStatusData&gt; statusData) &#123; init(); isPcLogin = true; pcDeviceID = item.deviceId; pcDeviceType = item.deviceType; isPadLogin = true; padDeviceID = item.deviceId; padDeviceType = item.deviceType; notifyListeners(); &#125; void init() &#123; isPcLogin = false; isPadLogin = false; pcDeviceID = ''; pcDeviceType = ''; padDeviceID = ''; padDeviceType = ''; &#125;&#125; 3.定义网络请求类网络请求将请求回来的数据转换为模型，并更新ViewModel数据。通过extension进行横向拓展 123456789101112131415161718192021extension DeviceOnlineStatusServices on DeviceOnlineStatusVM &#123; //获取设备状态 Future&lt;void&gt; getOnlineStatusServices() async &#123; HttpResp httpResp = await HttpApi().getOnlineStatus(); if (httpResp.code == 0) &#123; List jsonList = httpResp.value; List&lt;DeviceOnlineStatusData&gt; statusData = jsonList.map((e) =&gt; DeviceOnlineStatusData.fromJson(e)).toList(); setOnlineStatus(statusData); &#125; &#125; //更新设备状态 Future&lt;void&gt; setOnlineStatusServices(String deviceID, String deviceType) async &#123; HttpResp httpResp = await HttpApi().postOnlineStatus(deviceID, deviceType); if (httpResp.code == 0) &#123; List jsonList = httpResp.value; List&lt;DeviceOnlineStatusData&gt; statusData = jsonList.map((e) =&gt; DeviceOnlineStatusData.fromJson(e)).toList(); setOnlineStatus(statusData); &#125; &#125;&#125; 4.View数据展示层单独抽出View层，View用来渲染数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class DeviceOnlineStatusView extends StatelessWidget &#123; const DeviceOnlineStatusView(&#123;Key key, this.viewModel&#125;) : super(key: key); final DeviceOnlineStatusVM viewModel; @override Widget build(BuildContext context) &#123; return Flex( direction: Axis.vertical, children: &lt;Widget&gt;[ Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Image.asset(\"assets/images/im_device_pc.png\", width: 178, height: 92)], ), const SizedBox(height: 14.0), Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ TextImageButtonWidget( text: \"退出\", normalImage: \"im_device_back.png\", disableImage: \"im_device_back_disable.png\", buttonEnable: viewModel.isPcLogin, onTapCallBack: () &#123; Utils.showCommonDialog(context: context, content: '是否退出电脑登录?').then((value) async &#123; if (value) &#123; viewModel .setOnlineStatusServices(viewModel.pcDeviceID, viewModel.padDeviceType) .then((value) &#123; if (!viewModel.isPadLogin &amp;&amp; !viewModel.isPcLogin) &#123; Utils.popPage(); &#125; &#125;); &#125; &#125;); &#125;), ], ), ], ), ], ); &#125;&#125; 5.Controller用来将viewModel绑定View，并且管理生命周期123456789101112131415161718192021222324252627282930313233343536373839class DeviceOnlineStatusPage extends StatefulWidget &#123; const DeviceOnlineStatusPage(&#123; Key key, this.title, this.deviceOnlineStatusVM, &#125;) : super(key: key); final String title; final DeviceOnlineStatusVM deviceOnlineStatusVM; @override State&lt;StatefulWidget&gt; createState() =&gt; _DeviceOnlineStatusPage();&#125;class _DeviceOnlineStatusPage extends State&lt;DeviceOnlineStatusPage&gt; &#123; @override void initState() &#123; // 获取接口数据 widget.deviceOnlineStatusVM.getOnlineStatusServices(); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: NavigationAppBar(title: widget.title), body: ChangeNotifierProvider.value( value: widget.deviceOnlineStatusVM, child: Consumer&lt;DeviceOnlineStatusVM&gt;( builder: (context, _viewModel, _) &#123; return DeviceOnlineStatusView(viewModel: _viewModel); &#125;, ), ), ); &#125;&#125;","categories":[],"tags":[]},{"title":"9.SSL/TLS(为了更安全的通信)---《图解密码学》","slug":"crypt-night","date":"2020-06-06T16:08:18.000Z","updated":"2022-09-28T23:36:58.713Z","comments":true,"path":"2020/06/07/crypt-night/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/06/07/crypt-night/","excerpt":"","text":"9. SSL/TLS1\"SSL/TLS --- 为了更安全的通信\" SSL/TLS是世界上应用最广泛的密码通信方法。比如说，当在网上商城中输人信用卡号时，我们的Web浏览器就会使用SSL/TLS进行密码通信。使用SSL/TLS可以对通信对象进行认证，还可以确保通信内容的机密性。 SSL/TLS中综合运用了之前所学习的对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。严格来说，SSL（Secure Socket Layer)与TLS（Transport Layer Security）是不同的，TLS相当于是SSL的后续版本。不过，本章中所介绍的内容，大多是SSL和TLS两者兼备的，因此除具体介绍通信协议的部分以外，都统一写作SSL/TLS。 9.1 客户端与服务器 Bob书店是Alice经常光顾的一家网店，因为在Bob书店她可以搜索到新出版的图书，还可以通过信用卡快速完成支付，购买的书还能快递到家，真的很方便。 有一天，Alice 读了一本关于网络信息安全的书，书上说“互联网上传输的数据都是可以被窃听的”。Alice感到非常担心，自己在购买新书的时候输人的信用卡号会不会被窃听呢？ Alice看到Bob书店的网站下面写着一行字：“在以https://开头的网页中输人的信息将通过SSL/TLS发送以确保安全”。 的确，输人信用卡号的网页的URL是以 https:// 开头的，而不是一般的 http://。此外．在浏览这个网页时，Alice的web浏览器上还会显示一个小锁头的图标，看上去好像挺安全的。 但Alice心想，就算写着“通过SSL/TLS发送”我也不放心啊，到底在我的Web浏览器和Bob书店的网站之间都发生了哪些事呢？ 本章将要介绍的技术一一SSL/TLS就可以解答Alice的疑问。当进行SSL/TLS通信时，Web浏览器上就会显示一个小锁头的图标。 Alice的Web浏览器（客户端）和Bob书店的网站（服务器）进行HTTP通信 Alice和Bob书店之间的通信，实际上是Alice所使用的Web浏览器和Bob书店的Web服务器之间的通信。Web浏览器是Alice的计算机上运行的一个程序，而web服务器则是在Bob书店的计算机上运行的一个程序，它们都遵循一种叫作HTTP（Hyper Text Transfer Protocol, 超文本传输协议）的协议（protocol)来进行通信。其中，Web浏览器称为HTTP客户端，Web服务器称为HTTP服务器。 当Alice点击网页上的链接或者输人URL时，Web浏览器就会通过网络向Web服务器发送一个 “我要浏览这个网页“，的请求（request）。 Web服务器则将请求的网页内容发送给Web浏览器，以便对请求作出响应（response）。服务器和客户端之间所进行的处理就是请求和响应的往复。HTTP可以认为是在HTTP客户端与HTTP服务器之间进行请求和响应的规范。 Alice向Bob书店发送信用卡号也是使用HTTP来完成的（下图）。Alice输人信用卡号之后按下提交按钮，这时客户端（Web浏览器）就会将信用卡号作为HTTP请求发送给服务器。服务器则会将“生成订单”的网页作为HTTP响应返回给客户端。 不过，如果直接发送请求的话，信用卡号就很可能被窃听。下一节我们将探讨针对这种风险的对策。 **不使用SSL/TLS发送信用卡号的情形** 9.2 用SSL/TLS承载HTTP 什么是SSL,什么是TLS呢？官话说SSL是安全套接层(secure sockets layer)，TLS是SSL的继任者，叫传输层安全(transport layer security)。说白点，就是在明文的上层和TCP层之间加上一层加密，这样就保证上层信息传输的安全。如HTTP协议是明文传输，加上SSL层之后，就有了雅称HTTPS。它存在的唯一目的就是保证上层通讯安全的一套机制。 当Web浏览器发送信用卡号时，信用卡号的数据会作为客户端请求发送给服务器。如果通信内容被窃听者Eve所窃取，Eve就会得到信用卡号。 于是，我们可以用SSL（Secure Socket Layer）或者TLS（Transport Layer Security）作为对通信进行加密的协议，然后在此之上承載HTTP（下图）。通过将两种协议进行叠加，我们就可以对HTTP的通信（请求和响应）进行加密，从而防止窃听。通过SSL/TLS进行通信时，URL不是以http://开头，而是以https://开头。 以上就是SSL/TLS的简单介绍。 在大致了解了SSL/TLS之后，我们来整理一下SSL/TLS到底负责哪些工作。我们想要实现的是，通过本地的浏览器访问网络上的web服务器，并进行安全的通信。用上边的例子来说就是，Alice希望通过web浏览器向Bob书店发送信用卡号。在这里，我们有几个必须要解决的问题。 Alice的信用卡号和地址在发送到Bob书店的过程中不能被窃听。 Alice的信用卡号和地址在发送到Bob书店的过程中不能被篡改。 确认通信对方的Web服务器是真正的Bob书店。 在这里，（1）是机密性的问题；（2）是完整性的问题；而（3）则是认证的问题。 要确保机密性，可以使用对称加密。由于对称加密算法的密钥不能被攻击者预测，因此我们使用伪随机数生成器来生成密钥。若要将对称加密的密钥发送给通信对象，可以使用非对称加密算法完成密钥交换。要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。 要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。 好，工具已经找齐了，下面只要用一个“框架”（framework）将这些工具组合起来就可以了。SSL/TIS协议其实就扮演了这样一种框架的角色。 SSL/TLS也可以保护其他的协议 刚才我们提到用SSL/TLS承载HTTP通信，这是因为HTTP是一种很常用的协议。其实SSL/TLS上面不仅可以承载HTTP，还可以承载其他很多协议。例如，发送邮件时使用的SMTP（Simple Mail Transfer Protocol, 简单邮件传输协议）和接收邮件时使用的POP3（Post Office Protocol，邮局协议）都可以用SSL/TLS进行承载。在这样的情况下，SSL/TLS就可以对收发的邮件进行保护。 用SSL/TLS承载HTTP、SMTP和POP3的结构如下图所示。一般的电子邮件软件都可以完成发送和接收邮件这两种操作，其实是同时扮演了SMTP客户端和POP3客户端这两种角色。 9.3 https9.3.1 http和https HTTP协议：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL/TLS层，HTTPS的安全基础是SSL/TLS，因此加密的详细内容就需要SSL/TLS。 HTTPS协议的主要作用可以分为两种： 建立一个信息安全通道，来保证数据传输的安全； 确认网站的真实性。 HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、 身份认证的网络协议，比http协议安全。 9.3.2 https优缺点 https的优点 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在2014年8月份调整搜索引擎算法，并称 “比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https的缺点 虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的： HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； SSL/TLS证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 SSL/TLS证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些地方可以控制CA根证书的情况下，中间人攻击一样可行。","categories":[],"tags":[]},{"title":"8.证书(为公钥加上数字签名)---《图解密码学》","slug":"crypt-eight","date":"2020-05-31T13:22:12.000Z","updated":"2022-05-28T19:11:20.277Z","comments":true,"path":"2020/05/31/crypt-eight/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/05/31/crypt-eight/","excerpt":"","text":"8. 证书1\"证书 -- 为公钥加上数字签名\" 要开车得先考驾照．驾照上面记有本人的照片、姓名、出生日期等个人信息．以及有效期、准驾车辆的类型等信息，并由公安局在上面盖章。我们只要看到驾照，就可以知道公安局认定此人具有驾驶车辆的资格。 公钥证书（Public-Key Certificate，PKC)其实和驾照很相似，里面记有姓名、组织、邮箱地址等个人信息，以及属于此人的公钥，并由认证机构（Certification Authority、Certifying Authority, CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书（certificate）。 可能很多人都没听说过认证机构，认证机构就是能够认定 “公钥确实属于此人”，并能够生成数字签名的个人或者组织。认证机构中有国际性组织和政府所设立的组织，也有通过提供认证服务来盈利的一般企业，此外个人也可以成立认证机构。 8.1 证书的应用场景 下面我们来通过证书的代表性应用场景来理解证书的作用。 下图展示了Alice向Bob发送密文的场景，在生成密文时所使用的Bob的公钥是通过认证机构获取的。 认证机构必须是可信的，对于“可信的第三方”，下图中会使用Trent这个名字，这个词是从trust（信任）一词演变而来的。 下面让我们对照着上图来看一看这些步骤具体都做了些什么。 Bob生成密钥对 要使用公钥密码进行通信，首先需要生成密钥对。Bob生成了一对公钥和私钥，并将私钥自行妥善保管。在这里，密钥对是由Bob自己生成的，也可以由认证机构代为生成。 Bob在认证机构Trent注册自己的公钥 在这里Bob则将公钥发送给了认证机构Trent，这是因为Bob需要请认证机构Trent对他的公钥加上数字签名（也就是生成证书）。 Trent收到Bob的公钥后，会确认所收到的公钥是否为Bob本人所有（参见专栏：身份确认和认证业务准则） 专栏：身份确认和认证业务准则 认证机构确认”本人”身份的方法和认证机构的认证业务准则（CertificatePractice Statement, CPS，的内容有关。如果认证机构提供的是测试用的服务，那么可能完全不会进行任何身份确认。如果是政府部门运營的认证机构，可能就需要根据法律规定来进行身份确认。如果是企业面向内部设立的认证机构，那就可能会给部门负责人打电话直接确认。 例如，VeriSign的认证业务准则中将身份确认分为Class1 ~ 3共三个等级 Class1：通过向邮箱发送件来确认本人身份 Class2：通过第三方数据库来确认本人身份 Class3：通过当面认证和身份证明来确认本人身份 等级越高，身份确认越严格。 认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书 Trent对Bob的公钥加上数字签名。为了生成数字签名，需要Trent自身的私钥，因此Trent需要事先生成好密钥对。 Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书） 现在Alice需要向Bob发送密文，因此她从Trent处获取证书。证书中包含了Bob的公钥。 Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性 Alice使用认证机构Trent的公钥对证书中的数字签名进行验证。如果验证成功，就相当于确认了证书中所包含的公钥的确是属于Bob的。到这里，Alice就得到了合法的Bob的公钥。 Alice用Bob的公钥加密消息并发送给Bob Alice用Bob的公钥加密要发送的消息，并将消息发送给Bob。 Bob用自己的私钥解密密文得到Alice的消息 Bob收到Alice发送的密文，然后用自己的私钥解密，这样就能够看到Alice的消息了。 上面就是利用认证机构Trent进行公钥密码通信的流程。其中1、2、3这几个步骤仅在注册新公钥时才会进行，并不是每次通信都需要。此外，步骤 4 仅在Alice第一次用公钥密码向Bob发送消息时才需要进行，只要Alice将Bob的公钥保存在电脑中，在以后的通信中就可以直接使用了。 8.2 证书标准规范X.509 证书是由认证机构颁发的，使用者需要对证书进行验证，因此如果证书的格式千奇百怪那就不方便了。于是，人们制定了证书的标准规范，其中使用最广泛的是由ITU（International TelecommumcationUnion，国际电信联盟）和ISO（IntemationalOrganizationforStandardization, 国际标准化组织）制定的X.509规范。很多应用程序都支持x.509并将其作为证书生成和交换的标准规范。 X.509是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准，因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。X.509证书的结构是用ASN1(Abstract Syntax Notation One)进行描述数据结构，并使用ASN.1语法进行编码。 在一份证书中，必须证明公钥及其所有者的姓名是一致的。对X.509证书来说，认证者总是CA或由CA指定的人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式) 一般来说，一个数字证书内容可能包括基本数据（版本、序列号) 、所签名对象信息（ 签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥）、CA的数字签名，等等。 8.2.1 证书规范 前使用最广泛的标准为ITU和ISO联合制定的X.509的 v3版本规范 (RFC5280）, 其中定义了如下证书信息域： 版本号(Version Number）：规范的版本号，目前为版本3，值为0x2； 序列号（Serial Number）：由CA维护的为它所发的每个证书分配的一的列号，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节； 签名算法（Signature Algorithm）：数字签名所采用的算法，如： sha256-with-RSA-Encryption ccdsa-with-SHA2S6； 颁发者（Issuer）：发证书单位的标识信息，如 ” C=CN，ST=Beijing, L=Beijing, O=org.example.com，CN=ca.org。example.com ”； 有效期(Validity): 证书的有效期很，包括起止时间。 主体(Subject) : 证书拥有者的标识信息（Distinguished Name），如：” C=CN，ST=Beijing, L=Beijing, CN=person.org.example.com”； 主体的公钥信息(SubJect Public Key Info）：所保护的公钥相关的信息： 公钥算法 (Public Key Algorithm）公钥采用的算法； 主体公钥（Subject Unique Identifier）：公钥的内容。 颁发者唯一号（Issuer Unique Identifier）：代表颁发者的唯一信息，仅2、3版本支持，可选； 主体唯一号（Subject Unique Identifier）：代表拥有证书实体的唯一信息，仅2，3版本支持，可选： 扩展（Extensions，可选）: 可选的一些扩展。中可能包括： Subject Key Identifier：实体的秘钥标识符，区分实体的多对秘钥； Basic Constraints：一指明是否属于CA; Authority Key Identifier：证书颁发者的公钥标识符； CRL Distribution Points: 撤销文件的颁发地址； Key Usage：证书的用途或功能信息。 此外，证书的颁发者还需要对证书内容利用自己的私钥添加签名， 以防止别人对证书的内容进行篡改。 8.2.2 证书格式 X.509规范中一般推荐使用PEM(Privacy Enhanced Mail）格式来存储证书相关的文件。证书文件的文件名后缀一般为 .crt 或 .cer 。对应私钥文件的文件名后缀一般为 .key。证书请求文件的文件名后綴为 .csr 。有时候也统一用pem作为文件名后缀。 PEM格式采用文本方式进行存储。一般包括首尾标记和内容块，内容块采用Base64进行编码。 编码格式总结: X.509 DER(Distinguished Encoding Rules)编码，后缀为：.der .cer .crt X.509 BASE64编码(PEM格式)，后缀为：.pem .cer .crt 例如，一个PEM格式（base64编码）的示例证书文件内容如下所示： 1234567891011121314151617181920212223-----BEGIN CERTIFICATE-----MIIDyjCCArKgAwIBAgIQdZfkKrISoINLporOrZLXPTANBgkqhkiG9w0BAQsFADBnMSswKQYDVQQLDCJDcmVhdGVkIGJ5IGh0dHA6Ly93d3cuZmlkZGxlcjIuY29tMRUwEwYDVQQKDAxET19OT1RfVFJVU1QxITAfBgNVBAMMGERPX05PVF9UUlVTVF9GaWRkbGVyUm9vdDAeFw0xNzA0MTExNjQ4MzhaFw0yMzA0MTExNjQ4MzhaMFoxKzApBgNVBAsMIkNyZWF0ZWQgYnkgaHR0cDovL3d3dy5maWRkbGVyMi5jb20xFTATBgNVBAoMDERPX05PVF9UUlVTVDEUMBIGA1UEAwwLKi5iYWlkdS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDX0AM198jxwRoKgwWsd9oj5vI0and9v9SB9ChlgZEu6G9ZA0C7BucsBzJ2bl0Mf6qq0Iee1DfeydfEKyTmBKTafgb2DoQE3OHZjy0BQTJrsOdf5s636W5gJp4f7CUYYA/3e1nxr/+AuG44Idlsi17TWodVKjsQhjzH+bK68ukQZyel1SgBeQOivzxXe0rhXzrocoeKZFmUxLkUpm+/mX1syDTdaCmQ6LT4KYYisoKe4f+r2tLbUzPKxtk2F1v3ZLOjiRdzCOA27e5n88zdAFrCmMB4teG/azCSAH3gYb6vaAGaOnKyDLGunW51sSesWBpHceJnMfrhwxCjiv707JZtAgMBAAGjfzB9MA4GA1UdDwEB/wQEAwIEsDATBgNVHSUEDDAKBggrBgEFBQcDATAWBgNVHREEDzANggsqLmJhaWR1LmNvbTAfBgNVHSMEGDAWgBQ9UIffUQSuwWGOm+o74JffZJNadjAdBgNVHQ4EFgQUQh8IksZqcMVmKrIibTHLbAgLRGgwDQYJKoZIhvcNAQELBQADggEBAC5YJndwXpm0W+9SUlQhAUSE9LZh+DzcSmlCWtBk+SKBwmAegbfNSf6CgCh0VY6iIhbnGlszqgAOAqVMxAEDlR/YJTOlAUXFw8KICsWdvE01xtHqhk1tCK154Otci60Wu+tz1t8999GPbJskecbRDGRDSA/gQGZJuL0rnmIuz3macSVn6tH7NwdoNeN68Uj3Qyt5orYv1IFm8t55224ga8ac1y90hK4R5HcvN71aIjMKrikgynK0E+g45QypHRIe/z0S/1W/6rqTgfN6OWc0c15hPeJbTtkntB5Fqd0sfsnKkW6jPsKQ+z/+vZ5XqzdlFupQ29F14ei8ZHl9aLIHP5s=-----END CERTIFICATE----- 证书中的解析出来的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Certificate: Data: Version: 3 (0x2) Serial Number: 10:e6:fc:62:b7:41:8a:d5:00:5e:45:b6 Signature Algorithm: sha256WithRSAEncryption Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA-SHA256-G2 Validity Not Before: Nov 21 08:00:00 2016 GMT Not After : Nov 22 07:59:59 2017 GMT Subject: C=US, ST=California, L=San Francisco, O=Wikimedia Foundation, Inc., CN=*.wikipedia.org Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:c9:22:69:31:8a:d6:6c:ea:da:c3:7f:2c:ac:a5: af:c0:02:ea:81:cb:65:b9:fd:0c:6d:46:5b:c9:1e: ed:b2:ac:2a:1b:4a:ec:80:7b:e7:1a:51:e0:df:f7: c7:4a:20:7b:91:4b:20:07:21:ce:cf:68:65:8c:c6: 9d:3b:ef:d5:c1 ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature, Key Agreement Authority Information Access: CA Issuers - URI:http://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt OCSP - URI:http://ocsp2.globalsign.com/gsorganizationvalsha2g2 X509v3 Certificate Policies: Policy: 1.3.6.1.4.1.4146.1.20 CPS: https://www.globalsign.com/repository/ Policy: 2.23.140.1.2.2 X509v3 Basic Constraints: CA:FALSE X509v3 CRL Distribution Points: Full Name: URI:http://crl.globalsign.com/gs/gsorganizationvalsha2g2.crl X509v3 Subject Alternative Name: DNS:*.wikipedia.org, DNS:*.m.mediawiki.org, DNS:*.m.wikibooks.org, DNS:*.m.wikidata.org, DNS:*.m.wikimedia.org, DNS:*.m.wikimediafoundation.org, DNS:*.m.wikinews.org, DNS:*.m.wikipedia.org, DNS:*.m.wikiquote.org, DNS:*.m.wikisource.org, DNS:*.m.wikiversity.org, DNS:*.m.wikivoyage.org, DNS:*.m.wiktionary.org, DNS:*.mediawiki.org, DNS:*.planet.wikimedia.org, DNS:*.wikibooks.org, DNS:*.wikidata.org, DNS:*.wikimedia.org, DNS:*.wikimediafoundation.org, DNS:*.wikinews.org, DNS:*.wikiquote.org, DNS:*.wikisource.org, DNS:*.wikiversity.org, DNS:*.wikivoyage.org, DNS:*.wiktionary.org, DNS:*.wmfusercontent.org, DNS:*.zero.wikipedia.org, DNS:mediawiki.org, DNS:w.wiki, DNS:wikibooks.org, DNS:wikidata.org, DNS:wikimedia.org, DNS:wikimediafoundation.org, DNS:wikinews.org, DNS:wikiquote.org, DNS:wikisource.org, DNS:wikiversity.org, DNS:wikivoyage.org, DNS:wiktionary.org, DNS:wmfusercontent.org, DNS:wikipedia.org X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 Subject Key Identifier: 28:2A:26:2A:57:8B:3B:CE:B4:D6:AB:54:EF:D7:38:21:2C:49:5C:36 X509v3 Authority Key Identifier: keyid:96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C Signature Algorithm: sha256WithRSAEncryption 8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35: ... 8.2.3 CA证书 理论上，人人都可以找个证书工具，自己做一个证书。那如何防止坏人自己制作证书出来骗人捏？CA是Certificate Authority的缩写，也叫“证书授权中心”。 它是负责管理和签发证书的第三方机构, 好比一个可信任的中介公司。一般来说，CA必须是所有行业和所有公众都信任的、认可的。因此它必须具有足够的权威性。比如现实生活中我们要去公安局去办理身份证一样。 CA证书 CA 证书，顾名思义，就是CA颁发的证书。 前面已经说了，人人都可以找工具制作证书。但是因为你不是权威的CA机关，你自己搞的证书不具有权威性。 证书信任链 证书直接是可以有信任关系的, 通过一个证书可以证明另一个证书也是真实可信的. 实际上，证书之间的信任关系，是可以嵌套的。比如，C 信任 A1，A1 信任 A2，A2 信任 A3……这个叫做证书的信任链。只要你信任链上的头一个证书，那后续的证书，都是可以信任滴。 假设 C 证书信任 A 和 B；然后 A 信任 A1 和 A2；B 信任 B1 和 B2。则它们之间，构成如下的一个树形关系（一个倒立的树）。 处于最顶上的树根位置的那个证书，就是“根证书”。除了根证书，其它证书都要依靠上一级的证书，来证明自己。那谁来证明“根证书”可靠捏？实际上，根证书自己证明自己是可靠滴（或者换句话说，根证书是不需要被证明滴）。 聪明的同学此刻应该意识到了：根证书是整个证书体系安全的根本。所以，如果某个证书体系中，根证书出了问题（不再可信了），那么所有被根证书所信任的其它证书，也就不再可信了。 证书有啥用 验证网站是否可信（针对HTTPS） 通常，我们如果访问某些敏感的网页（比如用户登录的页面），其协议都会使用 HTTPS 而不是 HTTP。因为 HTTP 协议是明文的，一旦有坏人在偷窥你的网络通讯，他/她就可以看到网络通讯的内容（比如你的密码、银行帐号、等）；而 HTTPS 是加密的协议，可以保证你的传输过程中，坏蛋无法偷窥。 但是，千万不要以为，HTTPS 协议有了加密，就可高枕无忧了。光有加密是不够滴。假设有某人搞了一个假的网银的站点，然后诱骗你上这个站点。假设真的点击登录了就被骗了。 为了防止坏人这么干，HTTPS 协议除了有加密的机制，还有一套证书的机制。通过证书来确保，某个站点确实就是某个站点。 有了证书之后，当你的浏览器在访问某个 HTTPS 网站时，会验证该站点上的 CA 证书。如果浏览器发现该证书没有问题（证书被某个根证书信任、证书上绑定的域名和该网站的域名一致、证书没有过期），那么页面就直接打开；否则的话，浏览器会给出一个警告，告诉你该网站的证书存在某某问题，是否继续访问该站点？下面给出 IE 和 Firefox 的抓图： 大多数知名的网站，如果用了 HTTPS 协议，其证书都是可信的（也就不会出现上述警告）。所以，今后你如果上某个知名网站，发现浏览器跳出上述警告，你就要小心啦！ 验证某文件是否可信（是否被篡改） 证书除了可以用来验证某个网站，还可以用来验证某个文件是否被篡改。具体是通过证书来制作文件的数字签名。制作数字签名的过程太专业，咱就不说了。后面专门告诉大家如何验证文件的数字签名。考虑到大多数人用 Windows 系统，俺就拿 Windows 的例子来说事儿。 比如，俺手头有一个 Google Chrome的安装文件（带有数字签名）。当俺查看该文件的属性，会看到如下的界面。眼神好的同学，会注意到到上面有个“数字签名”的标签页。如果没有出现这个标签页，就说明该文件没有附带数字签名。 一般来说，签名列表中，有且仅有一个签名。选中它，点“详细信息”按钮。跳出如下界面： 通常这个界面会显示一行字：“该数字签名正常”（图中红圈标出）。如果有这行字，就说明该文件从出厂到你手里，中途没有被篡改过（是原装滴、是纯洁滴）。如果该文件被篡改过了（比如，感染了病毒、被注入木马），那么对话框会出现一个警告提示“该数字签名无效” 不论签名是否正常，你都可以点“查看证书”按钮。这时候，会跳出证书的对话框。如下： 从后一个界面，可以看到刚才说的证书信任链。图中的信任链有3层： 第1层是根证书（verisign）。 第2层是 symantec 专门用来签名的证书。 第3层是 Google自己的证书。 目前大多数知名的公司（或组织机构），其发布的可执行文件（比如软件安装包、驱动程序、安全补丁），都带有数字签名。你可以自己去看一下。 建议大伙儿在安装软件之前，都先看看是否有数字签名？如果有，就按照上述步骤验证一把。一旦数字签名是坏的，那可千万别装。 8.3 公钥基础设施（PKI） 仅制定证书的规范还不足以支持公钥的实际运用，我们还需要很多其他的规范，例如证书应该由谁来颁发，如何颁发，私钥泄露时应该如何作废证书，计算机之间的数据交换应采用怎样的格式等。这一节我们将介绍能够使公钥的运用更加有效的公钥基础设施。 8.3.1 什么是公钥基础设施 公钥基础设施（Public-Key infrastructure）是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。公钥基础设施一般根据其英语缩写而简称为PKI。 PKI只是一个总称，而并非指某一个单独的规范或规格。例如，RSA公司所制定的PKCS（Public-Key Cryptography Standards，公钥密码标准）系列规范也是PKI的一种，而互联网规格RFC（Requestfor Comments）中也有很多与PKI相关的文档。此外，X.509这样的规范也是PKI的一种。在开发PKI程序时所使用的由各个公司编写的API（Application Programming Interface, 应用程序编程接口）和规格设计书也可以算是PKI的相关规格。 因此，根据具体所采用的规格，PKI也会有很多变种，这也是很多人难以整体理解PKI的原因之一。 为了帮助大家整体理解PKI,我们来简单总结一下PKI的基本组成要素（用户、认证机构、仓库）以及认证机构所负责的工作。 8.3.2 PKI的组成要素PKI的组成要素主要有以下三个： 用户 — 使用PKI的人 认证机构 — 颁发证书的人 仓库 — 保存证书的数据库 用户 用户就是像Alice、Bob这样使用PKI的人。用户包括两种：一种是希望使用PKI注册自己的公钥的人，另一种是希望使用已注册的公钥的人。我们来具体看一下这两种用户所要进行的操作。 注册公钥的用户所进行的操作 生成密钥对（也可以由认证机构生成） 在认证机构注册公钥 向认证机构申请证书 根据需要申请作废已注册的公钥 解密接收到的密文 对消息进行数字签名 使用已注册公钥的用户所进行的操作 将消息加密后发送给接收者 验证数字签名 1234567891011121314/* ==================== 小知识点 ==================== 浏览器如何验证SSL证书1. 在IE浏览器的菜单中点击“工具 /Internet选项”，选择“内容”标签，点击“证书”按钮，然后就可以看到IE 浏览器已经信任了许多“中级证书颁发机构”和“受信任的根证书颁发机 构。当我们在访问该网站时，浏览器 就会自动下载该网站的SSL证书，并对证书的安全性进行检查。2. 由于证书是分等级的，网站拥有者可能从根证书颁发机构领到证书，也可能从根证书的下一级（如某个国家 的认证中心，或者是某个省发出的证书）领到证书。假设我们正在访问某个使用 了 SSL技术的网站，IE浏 览器就会收到了一个SSL证书，如果这个证书是由根证书颁发机构签发的，IE浏览器就会按照下面的步骤来 检查：浏览器使用内 置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信 任的颁证机构签发的，这个网站就是安全可靠的；如果该SSL证书不是根服 务器签发的，浏览器就会自动检 查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证 书也是可信的。*/ 认证机构（CA） 认证机构（Certification Authority，CA）是对证书进行管理的人。上面的图中我们给它起了一个名字叫作Trent。认证机构具体所进行的操作如下： 生成密钥对 (也可以由用户生成) 生成密钥对有两种方式：一种是由PKI用户自行生成，一种是由认证机构来生成。在认证机构生成用户密钥对的情况下，认证机构需要将私钥发送给用户，这时就需要使用PKCS#12（Personal Information Exchange Syntax Standard）等规范。 在注册公钥时对本人身份进行认证, 生成并颁发证书 在用户自行生成密钥对的情况下，用户会请求认证机构来生成证书。申请证书时所使用的规范是由PKCS#10（Certification Request Syntax Standard）定义的。 认证机构根据其认证业务准则（Certification Practice Statement，CPS）对用户的身份进行认证，并生成证书。在生成证书时，需要使用认证机构的私钥来进行数字签名。生成的证书格式是由PKCS#6 （Extended-Certificate Syntax Standard）和 X.509定义的。 作废证书 当用户的私钥丢失、被盗时，认证机构需要对证书进行作废（revoke）。此外，即便私钥安然无恙，有时候也需要作废证书，例如用户从公司离职导致其失去私钥的使用权限，或者是名称变更导致和证书中记载的内容不一致等情况。 纸质证书只要撕毁就可以作废了，但这里的证书是数字信息，即便从仓库中删除也无法作废，因为用户会保存证书的副本，但认证机构又不能人侵用户的电脑将副本删除。 要作废证书，认证机构需要制作一张证书==作废清单（Certificate Revocation List),简称为CRL==。 CRL是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单，并由认证机构加上数字签名。证书序列号是认证机构在颁发证书时所赋予的编号，在证书中都会记载。 PKI用户需要从认证机构获取最新的CRL,并查询自己要用于验证签名（或者是用于加密）的公钥证书是否已经作废这个步骤是非常重要的。 假设我们手上有Bob的证书，该证书有合法的认证机构签名，而且也在有效期内，但仅凭这些还不能说明该证书一定是有效的，还需要查询认证机构最新的CRL，并确认该证书是否有效。一般来说，这个检查不是由用户自身来完成的，而是应该由处理该证书的软件来完成，但有很多软件并没有及时更能CRL。 认证机构的工作中，公钥注册和本人身份认证这一部分可以由注册机构（Registration Authority，RA) 来分担。这样一来，认证机构就可以将精力集中到颁发证书上，从而减轻了认证机构的负担。不过，引入注册机构也有弊端，比如说认证机构需要对注册机构本身进行认证，而且随着组成要素的增加，沟通过程也会变得复杂，容易遭受攻击的点也会增。 仓库 仓库（repository）是一个保存证书的数据库，PKI用户在需要的时候可以从中获取证书．它的作用有点像打电话时用的电话本。在本章开头的例子中，尽管没特别提到，但Alice获取Bob的证书时，就可以使用仓库。仓库也叫作证书目录。 8.3.3 各种各样的PKI 公钥基础设施（PKI）这个名字总会引起一些误解，比如说“面向公众的权威认证机构只有一个”，或者“全世界的公钥最终都是由一个根CA来认证的”，其实这些都是不正确的。认证机构只要对公钥进行数字签名就可以了，因此任何人都可以成为认证机构，实际上世界上已经有无数个认证机构了。 国家、地方政府、医院、图书馆等公共组织和团体可以成立认证机构来实现PKI,公司也可以出于业务需要在内部实现PKI,甚至你和你的朋友也可以以实验为目的来构建PKI。 在公司内部使用的情况下，认证机构的层级可以像上一节中一样和公司的组织层级一一对应，也可以不一一对应。例如，如果公司在东京、大阪、北海道和九州都成立了分公司，也可以采取各个分公司之间相互认证的结构。在认证机构的运营方面，可以购买用于构建PKI的软件产品由自己公司运营，也可以使用VeriSign等外部认证服务。具体要采取怎样的方式，取决于目的和规模，并没有一定之规。","categories":[],"tags":[]},{"title":"7.数字签名(消息到底是谁写的)---《图解密码学》","slug":"crypt-seven","date":"2020-05-29T14:24:39.000Z","updated":"2022-05-28T19:11:44.832Z","comments":true,"path":"2020/05/29/crypt-seven/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/05/29/crypt-seven/","excerpt":"","text":"7. 数字签名1\"数字签名 --- 消息到底是谁写的\" 数字签名是一种将相当于现实世界中的盖章、签字的功能在计算机世界中进行实现的技术。使用数字签名可以识别篡改和伪装，还可以防止否认。 7.1 从消息认证到数字签名 消息认证码的局限性 通过使用第6章中介绍的消息认证码，我们可以识别消息是否被篡改或者发送者身份是否被伪装，也就是可以校验消息的完整性，还可以对消息进行认证。然而，比如在出具借条的场景中却无法使用消息认证码，因为消息认证码无法防止否认。 消息认证码之所以无法防止否认，是因为消息认证码需要在发送者Alice和接收者Bob两者之间共享同一个密钥。正是因为密钥是共享的，所以能够使用消息认证码计算出正确MAC值的并不只有发送者Alice，接收者Bob也可以计算出正确的MAC值。由于Alice和Bob双方都能够计算出正确的MAC值，因此对于第三方来说，我们无法证明这条消息的确是由Alice生成的。 通过数字签名解决问题 假设发送者Alice和接收者Bob不需要共享一个密钥，也就是说，Alice和Bob各自使用不同的密钥。 我们假设Alice使用的密钥是一个只有Alice自己才知道的私钥。当Alice发送消息时，她用私钥生成一个“签名”。相对地，接收者Bob则使用一个和Alice不同的密钥对签名进行验证。使用Bob的密钥无法根据消息生成签名，但是用Bob的密钥却可以对Alice所计算的签名进行验证，也就是说可以知道这个签名是否是通过Alice的密钥计算出来的。如果真有这么一种方法的话，那么不管是识别篡改、伪装还是防止否认就都可以实现了吧 ？ 实际上这就是数字签名（digital signature）。 7.2 签名的生成和验证 在数字签名技术中，出现了下面两种行为： 生成消息签名的行为 验证消息签名的行为 生成消息签名这一行为是由消息的发送者Alice来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着 “我认可该消息的内容”。 验证数字签名这一行为一般是由消息的接收者Bob来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方我们暂且将其命名为验证者Victor。验证签名就是检查该消息的签名是否真的属于Alice，验证的结果可以是成功或者失败，成功就意味着这个签名是属于Alice的，失败则意味着这个签名不是属于Alice的。 在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。 Alice使用“签名密钥”来生成消息的签名，而Bob和Victor则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。这一点非常重要。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。 刚才讲的这部分内容，是不是觉得似曾相识呢？ 没错，这就是我们讲过的非对称加密。公钥密码和上面讲的数字签名的结构非常相似。在非对称加密中，密钥分为加密密钥和解密密钥，用加密密钥无法进行解密。此外，解密密钥只能由需要解密的人持有，而加密密钥则是任何需要加密的人都可以持有。你看，数字签名和非对称加密是不是很像呢？ 实际上，数字签名和非对称加密有着非常紧密的联系，简而言之，数字签名就是通过将非对称加密 “反过来用” 而实现的。下面我们来将密钥的使用方式总结成一张表： 私钥 公钥 非对称加密 接收者解密时使用 发送者加密时使用 数字签名 签名者生成签名时使用 验证者验证签名时使用 谁持有秘钥 个人持有 只要需要，任何人都可以持有 7.3 非对称加密和数字签名 下面我们再来详细讲一讲非对称加密与数字签名之间的关系。 要实现数字签名，我们可以使用第4章中介绍的非对称加密。非对称加密包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。 数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和非对称加密是相反的，即用私钥加密相当于生成签名，而用公钥解密则相当于验证签名。请大家通过比较两张图示来理解一下“反过来用”到底是什么样的情形。 那么为什么加密相当于生成签名，而解密相当于验证签名呢？要理解这个问题，我们需要回想一下非对称加密中讲过的知识，即组成密钥对的两个密钥之间存在严密的数学关系，它们是一对无法拆散的伙伴。 用公钥加密所得到的密文，只能用与该公钥配对的私钥才能解密：同样地，用私钥加密所得到的密文，也只能用与该私钥配对的公钥才能解密。也就是说，如果用某个公钥成功解密了密文，那么就能够证明这段密文是用与该公钥配对的私钥进行加密所得到的。 用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，我们才可以将用私钥加密的密文作为签名来对待。 由于公钥是对外公开的，因此任何人都能够用公钥进行解密，这就产生了一个很大的好处，即任何人都能够对签名进行验证。 7.3 数字签名的方法 下面我们来具体介绍两种生成和验证数字签名的方法。 直接对消息签名的方法 对消息的散列值签名的方法 直接对消息签名的方法比较容易理解，但实际上并不会使用；对消息的散列值签名的方法稍微复杂一点，但实际中我们一般都使用这种方法。 使用直接对消息签名的方法，需要对整个消息进行加密，非常耗时，这是因为非对称加密算法本来就非常慢。那么，我们能不能生成一条很短的数据来代替消息本身呢？这就是单向散列函数。 于是我们不必再对整个消息进行加密（即对消息签名），而是只要先用单向散列函数求出消息的散列值，然后再将散列值进行加密（对散列值签名）就可以了。无论消息有多长，散列值永远都是这么短，因此对其进行加密（签名）是非常轻松的。 （1）Alice用单向散列函数计算消息的散列值。 （2）Alice用自己的私钥对散列值进行加密。 用私钥加密散列值所得到的密文就是Alice对这条散列值的签名，由于只有Alice才持有自己的私钥因此, 除了Alice以外，其他人是无法生成相同的签名（密文）的。（3）Alice将消息和签名发送给Bob。 （4）Bob用Alice的公钥对收到的签名进行解密。 如果收到的签名确实是用Alice的私钥进行加密而得到的密文（签名），那么用Alice的公钥应该能够正确 解密，解密的结果应该等于消息的散列值。如果收到的签名不是用Alice的私钥进行加密而得到的密文， 那么就无法用Alice的公钥正确解密（解密后得到的数据看起来是随机的）。（5）Bob将签名解密后得到的散列值与Alice直接发送的消息的散列值进行对比。 如果两者一致，则签名验证成功；如果两者不一致，则签名验证失败。我们将数字签名中生成签名和验证签名的过程整理成一张时间流程图 。 **Alice对消息的散列值签名, Bob验证签名** **Alice对消息的散列值签名, Bob验证签名(按时间顺序)** 7.4 数字签名无法解决的问题 用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及否认防止。现代社会中的计算机通信从这一技术中获益匪浅。 然而，要正确使用数字签名，有一个大前提，那是用于验证签名的公钥必须属于真正的发送者。即便数字签名算法再强大，如果你得到的公钥是伪造的，那么数字签名也会完全失效。 现在我们发现自己陷人了一个死循环一一一数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。 为了能够确认自己得到的公钥是否合法，我们需要使用证书。所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。 当然，这样的方法只是把问题转移了而已。为了对证书上施加的数字签名进行验证，我们必定需要另一个公钥，那么如何才能构筑一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏人了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即公钥基础设施（Public Key Intrastructure），简称PKIO关于证书和PKI我们将在第8章中介绍。","categories":[],"tags":[]},{"title":"6.消息认证码(消息被正确传送了吗)---《图解密码学》","slug":"crypt-six","date":"2020-05-21T13:09:14.000Z","updated":"2022-05-28T19:11:50.512Z","comments":true,"path":"2020/05/21/crypt-six/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/05/21/crypt-six/","excerpt":"","text":"6.1 什么是消息认证码 Alice 和 Bob 的故事 像以前一样，我们还是从一个Alice和Bob的故事开始讲起。不过，这一次Alice和Bob分别是两家银行，Alice银行通过网络向Bob银行发送了一条汇款请求，Bob银行收到的请求内容是： 从账户A-5374 向账户B-6671汇款1000万元 当然，Bob银行所收到的汇款请求内容必须与Alice银行所发送的内容是完全一致的。如果主动攻击者Mallory在中途将Alice银行发送的汇款请求进行了篡改，那么Bob银行就必须要能够识别出这种篡改，否则如果Mallory将收款账户改成了自己的账户，那么1000万元就会被盗走。 话说回来，这条汇款请求到底是不是Alice银行发送的呢？有可能Alice银行根本就没有发送过汇款请求，而是由主动攻击者Mallory伪装成Alice银行发送的。如果汇款请求不是来自Alice银行，那么就绝对不能执行汇款。 现在我们需要关注的问题是汇款请求（消息）的 “完整性” 和 “认证” 这两个性质。 消息的完整性（integrity), 指的是“消息没有被篡改”这一性质，完整性也叫一致性。如果能够确认汇款请求的内容与Alice银行所发出的内容完全一致，就相当于是确认了消息的完整性，也就意味着消息没有被篡改。 消息的认证（authentication）指的是“消息来自正确的发送者”这一性质。如果能够确认汇款请求确实来自Alice银行，就相当于对消息进行了认证，也就意味着消息不是其他人伪装成发送者所发出的。 通过使用本章中要介绍的消息认证码，我们就可以同时识别出篡改和伪装，也就是既可以确认消息的完整性，也可以进行认证。 什么是消息认证码 消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称为MAC。 消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为MAC值。 根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，而消息认证码中则需要使用发送者与接收者之间共享的密钥。 要计算MAC必须持有共享密钥，没有共享密钥的人就无法计算MAC值，消息认证码正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值也会产生变化，消息认证码正是利用这一性质来确认完整性的。 消息认证码有很多种实现方法，大家可以暂且这样理解：消息认证码是一种与密钥相关联的单向散列函数。 单向散列函数与消息认证码的比较 6.2 消息认证码的使用步骤 我们还是以Alice银行和Bob银行的故事为例，来讲解一下消息认证码的使用步骤: 发送者Alice与接收者Bob事先共享密钥。 发送者Alice根据汇款请求消息计算MAC值（使用共享密钥）。 发送者Alice将汇款请求消息和MAC值两者发送给接收者Bob。 接收者Bob根据接收到的汇款请求消息计算MAC值（使用共享密钥）。 接收者Bob将自己计算的MAC值与从Alice处收到的MAC值进行对比。 如果两个MAC值一致，则接收者Bob就可以断定汇款请求的确来自Alice（认证成功）；如果不一致，则可以断定消息不是来自Alice（认证失败）。 6.3 HMAC6.3.1 HMAC介绍 HMAC是一种使用单向散列函数来构造消息认证码的方法（RFC2104），其中HMAC的H就是Hash的意思。 HMAC中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC,如果将来设计出新的单向散列函数，也同样可以使用。 使用SHA-I、MD5、RIPEMD-160所构造的HMAC，分别称为HMAC-SHA-1、HMAC-MD5和HMAC-RlPEMD。 **使用HMAC通过秘钥将消息生成消息认证码的内部实现**： 通过上述流程我们可以看出，最后得到的MAC值，一定是一个和输入的消息以及密钥都相关的长度固定的比特序列。 6.3.2 消息认证码的密钥配送问题 在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，这样一来消息认证码就无法发挥作用了。 发送者和接收者需要共享密钥，这一点和我们介绍的对称加密很相似。实际上，对称加密的密钥配送问题在消息认证码中也同样会发生。 6.4 消息认证码无法解决的问题 假设发送者Alice要向接收者Bob发送消息，如果使用了消息认证码，接收者Bob就能够断定自己收到的消息与发送者Alice所发出的消息是一致的，这是因为消息中的MAC值只有用Alice和Bob之间共享的密钥才能够计算出来，即便主动攻击者Mallory篡改消息，或者伪装成Alice发送消息，Bob也能够识别出消息的篡改和伪装。 但是，消息认证码也不能解决所有的问题，例如“对第三方证明”和“防止否认”，这两个问题就无法通过消息认证码来解决。下面我们来逐一解释一下。 6.4.1 对第三方证明 假设Bob在接收了来自Alice的消息之后，想要向第三方验证者Victor证明这条消息的确是Alice发送的，但是用消息认证码无法进行这样的证明，这是为什么呢？ 首先，Victor要校验MAC值，就需要知道Alice和Bob之间共享的密钥。 假设Bob相信Victor, 同意将密钥告诉Victor,即便如此，Victor也无法判断这条消息是由Alice发送的，因为Victor可以认为：“即使MAC值是正确的，发送这条消息的人也不一定是Alice，还有可能是Bob。” 能够计算出正确MAC值的人只有Alice和Bob，在他们两个人之间进行通信时，可以断定是对方计算了MAC值，这是因为共享这个密钥的双方之中，有一方就是自己。然而，对于第三方Victor、Alice或Bob却无法证明是对方计算了MAC值，而不是自己。 使用第7章中将要介绍的数字签名就可以实现对第三方的证明。 6.4.2 防止否认 假设Bob收到了包含MAC值的消息，这个MAC值是用Alice和Bob共享的密钥计算出来的，因此Bob能够判断这条消息的确来自Alice。 但是，上面我们讲过，Bob无法向验证者Victor证明这一点，也就是说，发送者Alice可以向Victor声称：“我没有向Bob发送过这条消息。”这样的行为就称为否认（repudiation）。 Alice可以说“这条消息是Bob自己编的吧”，“说不定Bob的密钥被主动攻击者Mallory给盗取了，我的密钥可是妥善保管着呢” 等。说白了，就是Alice和Bob吵起来了。 即便Bob拿MAC值来举证，Victor也无法判断Alice和Bob谁的主张才是正确的，也就是说，用消息认证码无法防止否认（nonrepudiatlon）。 6.5 总结 消息认证码是对消息进行认证并确认其完整性的技术。通过使用发送者和接收者之间共享的密钥，就可以识别出是否存在伪装和篡改行为。 消息认证码可以使用单向散列函数HMAC。 消息认证码中，由于发送者和接收者共享相同的密钥，因此会产生无法对第三方证明以及无法防止否认等问题。在下一章中，我们将介绍能够解决这些问题的数字签名。","categories":[],"tags":[]},{"title":"5.单向散列函数(获取消息的指纹)---《图解密码学》","slug":"crypt-five-md","date":"2020-05-12T12:10:18.000Z","updated":"2022-05-28T19:11:24.724Z","comments":true,"path":"2020/05/12/crypt-five-md/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/05/12/crypt-five-md/","excerpt":"","text":"5.单向散列函数(获取消息的指纹)1\"单向散列函数 --- 获取消息的指纹\" 在刑事侦查中，侦查员会用到指纹。通过将某个特定人物的指纹与犯罪现场遗留的指纹进行对比，就能够知道该人物与案件是否存在关联。 针对计算机所处理的消息，有时候我们也需要用到“指纹”。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”就可以了。 本章中，我们将学习单向散列函数的相关知识。使用单向散列函数就可以获取消息的“指纹”，通过对比 “指纹”，就能够知道两条消息是否一致。 下面，我们会先简单介绍一下单向散列函数，并给大家展示具体的例子。然后我们将详细介绍现在使用非常广泛的SHA-I单向散列函数。 5.1 什么是单向散列函数 单向散列函数（one-wayftnction）有一个输人和一个输出，其中输人称为消息（message），输出称为散列值（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。 这里的消息不一定是人类能够读懂的文字，也可以是图像文件或者声音文件。单向散列函数不需要知道消息实际代表的含义。无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。 散列值的长度和消息的长度无关。无论消息是1比特，还是100MB，甚至是IOOGB，单向散列函数都会计算出固定长度的散列值。以SHA-I单向散列函数为例，它所计算出的散列值的长度永远是160比特（20字节）。 5.2 关于术语 单向散列函数的相关术语有很多变体，不同参考资料中所使用的术语也不同，下面我们就介绍其中的儿个。 单向散列函数也称为消息摘要函数（message digest function）、哈希函数或者杂凑函数。 输人单向散列函数的消息也称为原像（pre-image）。 单向散列函数输出的散列值也称为消息摘要（message digest）或者指纹（fingerprint）。 完整性也称为一致性。 顺便说一句，单向散列函数中的“散列”的英文”hash一词，原意是古法语中的“斧子”，后来被引申为“剁碎的肉末”，也许是用斧子一通乱剁再搅在一起的那种感觉吧。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。 5.3 单向散列函数的性质 通过使用单向散列函数，即便是确认几百MB大小的文件的完整性，也只要对比很短的散列值就可以了。那么，单向散列函数必须具备怎样的性质呢？我们来整理一下。 根据任意长度的消息计算出固定长度的散列值 首先，单向散列函数的输人必须能够是任意长度的消息。 其次，无论输人多长的消息，单向散列函数必须都能够生成长度很短的散列值，如果消息越长生成的散列值也越长的话就不好用了。从使用方便的角度来看，散列值的长度最好是短且固定的。 能够快速计算出散列值 计算散列值所花费的时间必须要短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。 消息不同散列值也不同 为了能够确认完整性，消息中哪怕只有1比特的改变，也必须有很高的概率产生不同的散列值。 如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。两个不同的消息产生同一个散列值的情况称为碰撞（collision）。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被人为地发现碰撞。 难以发现碰撞的性质称为抗碰撞性（collisionresistance）。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。 强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的这一性质。在这里，散列值可以是任意值。密码技术中的单向散列函数必须具备强抗碰撞性。 具备单向性 单向散列函数必须具备单向性（one-way）。单向性指的是无法通过散列值反算出消息的性质。根据消息计算散列值可以很容易，但这条单行路是无法反过来走的。 正如同将玻璃砸得粉碎很容易，但却无法将碎片还原成完整的玻璃一样，根据消息计算出散列值很容易，但根据散列值却无法反算出消息。 在这里需要注意的一点是，尽管单向散列函数所产生的散列值是和原来的消息完全不同的比特序列，但是单向散列函数并不是一种加密，因此无法通过解密将散列值还原为原来的消息。 5.4 单向散列函数的实际应用 下面我们来看一下实际应用单向散列函数的例子。 5.4.1 检测软件是否被篡改 我们可以使用单向散列函数来确认自己下载的软件是否被篡改。 很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。 这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改方面发挥重要作用。 5.4.2 消息认证码 使用单向散列函数可以构造消息认证码。 消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。 消息认证码在SSL/TLS中也得到了运用，关于SSL/TLS我们将后边章节中介绍。 5.4.3 数字签名 在进行数字签名时也会使用单向散列函数。 数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。 5.4.6 伪随机数生成器 使用单向散列函数可以构造伪随机数生成器。 密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。 5.4.7 一次性口令 使用单向散列函数可以构造一次性口令（one-time password）。 一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。 5.5 常用的单向散列函数5.5.1 MD4、MD5 MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。 MD5是由Rwest于1991年设计的单项散列函数，能够产生128比特的散列值（RFC1321）。 MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已经不安全了。 MD4和MD5中的MD是消息摘要（Message Digest）的缩写。 5.5.3 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 SHA-1是由NIST（NationalInstituteOfStandardsandTechnology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。 SHA-1的消息长度存在上限，但这个值接近于2^64^比特，是个非常巨大的数值，因此在实际应用中没有问题。 SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64^ 比特，SHA-384 和 SHA-512的上限接近于 2^128^ 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。 比特数 字节数 MD4 128bit 16byte MD5 128bit 16byte SHA-1 160bit 20byte SHA-224 224bit 28byte SHA-256 256bit 32byte SHA-384 384bit 48byte SHA-512 512bit 64byte","categories":[],"tags":[]},{"title":"4.非对称加密(公钥加密,私钥解密)---《图解密码学》","slug":"crypt-four-md","date":"2020-05-08T10:10:10.000Z","updated":"2022-05-28T19:11:29.093Z","comments":true,"path":"2020/05/08/crypt-four-md/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/05/08/crypt-four-md/","excerpt":"","text":"1&quot;非对称加密也叫公钥密码: 使用公钥加密, 使用私钥解密&quot; 在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用非对称加密也可以称为公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。可以说非对称加密是密码学历史上最伟大的发明。 非对称加密中，密钥分为加密密钥和解密密钥两种。发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。要理解公钥密码，清楚地区分加密密钥和解密密钥是非常重要的。加密密钥是发送者加密时使用的，而解密密钥则是接收者解密时使用的。 仔细思考一下加密密钥和解密密钥的区别，我们可以发现： 发送者只需要加密密钥 接收者只需要解密密钥 解密密钥不可以被窃听者获取 加密密钥被窃听者获取也没问题 也就是说，解密密钥从一开始就是由接收者自己保管的，因此只要将加密密钥发给发送者就可以解决密钥配送问题了，而根本不需要配送解密密钥。 非对称加密中，加密密钥一般是公开的。正是由于加密密钥可以任意公开，因此该密钥被称为公钥（publickey）。公钥可以通过邮件直接发送给接收者，也可以刊登在报纸的广告栏上，做成看板放在街上，或者做成网页公开给世界上任何人，而完全不必担心被窃听者窃取。 当然，我们也没有必要非要将公钥公开给全世界所有的人，但至少我们需要将公钥发送给需要使用公钥进行加密的通信对象（也就是给自己发送密文的发送者）。 相对地，解密密钥是绝对不能公开的，这个密钥只能由你自己来使用，因此称为私钥（privatekey）。私钥不可以被别人知道，也不可以将它发送给别人，甚至也不能发送给自己的通信对象。 公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（keypair）。由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。密钥对中的两个密钥之间具有非常密切的关系(数学上的关系)一一因此公钥和私钥是不能分别单独生成的。 公钥密码的使用者需要生成一个包括公钥和私钥的密钥对，其中公钥会被发送给别人，而私钥则仅供自己使用。稍后我们将具体尝试生成一个密钥对。 4.1 非对称加密通信流程 下面我们来看一看使用公钥密码的通信流程。和以前一样、我们还是假设Alice要给Bob发送一条消息，Alice是发送者，Bob是接收者，而这一次窃听者Eve依然能够窃所到他们之间的通信内容。 在公非对称加密通信中，通信过程是由接收者Bob来启动的。 Bob生成一个包含公钥和私钥的密钥对。 私钥由Bob自行妥善保管。 Bob将自己的公钥发送给Alicea Bob的公钥被窃听者Eve截获也没关系。 将公钥发送给Alice，表示Bob请Alice用这个公钥对消息进行加密并发送给他。 Alice用Bob的公钥对消息进行加密。 加密后的消息只有用Bob的私钥才能够解密。 虽然Alice拥有Bob的公钥，但用Bob的公钥是无法对密文进行解密的。 Alice将密文发送给Bobo 密文被窃听者Eve截获也没关系。Eve可能拥有Bob的公钥，但是用Bob的公钥是无法进行解密的。 Bob用自己的私钥对密文进行解密。 请参考下图, 看一看在Alice和Bob之间到底传输了哪些信息。其实它们之间所传输的信息只有两个：Bob的公钥以及用Bob的公钥加密的密文。由于Bob的私钥没有出现在通信内容中，因此窃听者Eve无法对密文进行解密。 窃听者Eve可能拥有Bob的公钥，但是Bob的公钥只是加密密钥，而不是解密密钥，因此窃听者Eve就无法完成解密操作。 4.2 RSA RSA是一种非对称加密算法，它的名字是由它的三位开发者，即RonRivest、AdiShamir和LeonardAdleman 的姓氏的首字母组成的（Rivest-Shamir-Leonard）。 RSA可以被用于非对称加密和数字签名. 1983年，RSA公司为RSA算法在美国取得了专利，但现在该专利已经过期。 4.2.1 RSA加密 在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达，如下。 密文=明文 ^ E mod N（RSA加密） 也就是说，RSA的密文是对代表明文的数字的E次方求modN的结果。换句话说，就是将明文自己做E次乘法，然后将其结果除以N求余数，这个余数就是密文。 对，就这么简单。仅仅对明文进行乘方运算并求mod即可，这就是整个加密的过程。在对称密码中，出现了很多复杂的函数和操作，就像做炒鸡蛋一样将比特序列挪来挪去，还要进行XOR(按位异或)等运算才能完成，但RSA却不同，它非常简洁。 对了，加密公式中出现的两个数一一一E和N，到底都是什么数呢？RSA的加密是求明文的E次方modN，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，E和N是RSA加密的密钥，也就是说，E和N的组合就是公钥。 不过，E和N并不是随便什么数都可以的，它们是经过严密计算得出的。顺便说一句，E是加密（Encryption）的首字母，N是数字（Number)的首字母。 有一个很容易引起误解的地方需要大家注意一一E和N这两个数并不是密钥对（公钥和私钥的密钥对）。E和N两个数才组成了一个公钥，因此我们一般会写成 “公钥是(E，N)” 或者 “公钥是{E, N}” 这样的形式，将E和N用括号括起来。 现在大家应该已经知道，RSA的加密就是 “求E次方的modN”，接下来我们来看看RSA的解密。 4.2.2 RSA解密 RSA的解密和加密一样简单，可以用下面的公式来表达： 明文=密文^D mod N（RSA解密） 也就是说，对表示密文的数字的D次方求modN就可以得到明文。换句话说，将密文自己做D次乘法，再对其结果除以N求余数，就可以得到明文。 这里所使用的数字N和加密时使用的数字N是相同的。数D和数N组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。只有知道D和N两个数的人才能够完成解密的运算。 大家应该已经注意到，在RSA中，加密和解密的形式是相同的。加密是求 “E次方的mod N”，而解密则是求 “D次方的modN”，这真是太美妙了。 当然，D也并不是随便什么数都可以的，作为解密密钥的D，和数字E有着相当紧密的联系。否则，用E加密的结果可以用D来解密这样的机制是无法实现的。 顺便说一句，D是解密〈Decryption）的首字母，N是数字（Number）的首字母。 我们将上面讲过的内容整理一下，如下表所示。 RSA的加密和解密 4.3 ECC椭圆曲线 概念 椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。 ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。 椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。 ECC 164位的密钥产生的一个安全级相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用 256 位的椭圆曲线密码，虚拟货币比特币也选择ECC作为加密算法。 具体算法详解参考： https://www.cnblogs.com/Kalafinaian/p/7392505.html https://blog.csdn.net/taifei/article/details/73277247 数学原理 不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。 椭圆曲线依赖的数学难题是: k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知Q和P，很难计算出k 4.4 非对称加密解惑 非对称加密比对称加密机密性更高吗? 这个问题无法回答, 以为机密性高低是根据秘钥长度而变化的 采用1024bit 秘钥长度的非对称加密, 和采用128bit秘钥长度的对称加密中, 是秘钥更长的非对称加密更安全吗? 不是。 非对称加密的密钥长度不能与对称加密的密钥长度进行直接比较。下表是一张密钥长度的比较表（本表摘自《应用密码学》），根据这张表我们可以看出，1024比特的公钥密码与128比特的对称密码相比，反而是128比特的对称密码抵御暴力破解的能力更强。 对称加密秘钥长度 非对称加密秘钥长度 128 比特 2304 比特 112 比特 1792 比特 80 比特 768 比特 64 比特 512 比特 56 比特 384 比特 有了非对称加密， 以后对称加密会被替代吗？ 不会。 一般来说，在采用具备同等机密性的密钥长度的情况下，非对称加密的处理速度只有对称加密的几百分之一。因此，非对称加密并不适合用来对很长的消息内容进行加密。根据目的的不同，还可能会配合使用对称加密和非对称加密，例如，混合密码系统就是将这两种密码组合而成的。","categories":[],"tags":[]},{"title":"3. 分组密码的模式(分组密码是如何迭代)---《图解密码学》","slug":"crypt-three-md","date":"2020-05-05T05:14:10.000Z","updated":"2022-05-28T19:11:55.237Z","comments":true,"path":"2020/05/05/crypt-three-md/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/05/05/crypt-three-md/","excerpt":"","text":"分组密码的模式 我们在上一章中介绍的DES和AES都属于分组密码，它们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。 分组密码有很多种模式，如果模式的选择不恰当，就无法保证机密性。例如，如果使用ECB模式，明文中的一些规律就可以通过密文被识别出来。 分组密码的主要模式（ECB、CBC、CFB、OFB、CTR），最后再来考察一下到底应该使用哪一种模式。 3.1 分组密码 分组密码（blockcipher）是每次只能处理特定长度的一块数据的一类密码算法，这里的一块”就称为分组（block）。此外，一个分组的比特数就称为分组长度（blocklength）。 例如，DES和三重DES的分组长度都是64比特。这些密码算法一次只能加密64比特的明文．并生成64比特的密文。 AES的分组长度可以从128比特、192比特和256比特中进行选择。当选择128比特的分组长度时，AES一次可加密128比特的明文，并生成128比特的密文。 3.2 模式 分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。 话说到这里，很多读者可能会说：“如果明文很长的话，将明文分割成若干个分组再逐个加密不就好了吗？”事实上可没有那么简单。将明文分割成多个分组并逐个加密的方法称为ECB模式，这种模式具有很大的弱点（稍后讲解）。对密码不是很了解的程序员在编写加密软件时经常会使用ECB模式，但这样做会在不经意间产生安全漏洞，因此大家要记住千万不能使用ECB模式。 模式有很多种类，分组密码的主要模式有以下5种： ECB模式：Electronic Code Book mode（电子密码本模式） CBC模式：Cipher Block Chaining mode（密码分组链接模式） CFB模式：Cipher FeedBack mode（密文反馈模式） OFB模式：Output FeedBack mode（输出反馈模式） CTR模式：CounTeR mode（计数器模式） 明文分组和密文分组 在介绍模式之前，我们先来学习两个术语。 *明文分组: *是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。 *密文分组: *是指使用分组密码算法将明文分组加密之后所生成的密文。 为了避免图示变得复杂，以后我们将“用分组密码算法加密”简写为“加密”，并省略对密钥的描述。 3.3 ECB 模式 ECB(Electronic Code Book, 电子密码本)模式是最简单的加密模式，明文消息被分成固定大小的块（分组），并且每个块被单独加密。 每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以可以进行并行计算，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，安全性比较差。 适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。 使用ECB模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组–&gt;密文分组”的对应表，因此ECB模式也称为电子密码本模式当最后一个明文分组的内容小于分组长度时，需要用一特定的数据进行填充（padding），让值一个分组长度等于分组长度。 ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。 3.3 CBC模式XOR 为了让大家理解比特序列运算的概念，我们来介绍一下XOR运算。XOR的全称是exclusive or，在中文里叫作异或。尽管名字看起来很复杂，但这种运算本身一点都不难。 1个比特（bit）的位运算规则如下： 如果将0理解为偶数， 1理解为奇数，就可以将XOR和一般的加法运算等同起来。 由于XOR和加法运算很相似，因此一般用+和O组合而成的符号⊕来表示XOR。 为了更加直观地理解XOR，大家可以想象一下黑白棋（奥赛罗棋）中的棋子。 将一个棋子保持原状（不翻转）看做0 将一个棋子翻转到另一面看做1 那么XOR运算就相当于将黑白棋的一个棋子进行翻转的操作。 通过上述场景，大家应该能够理解这样一个规律，即两个相同的数进行XOR运算的结果一定为0，因为棋子翻转两次和一次都没有翻转的结果是一样的。 上面我们介绍了1个比特之间的XOR运算，而如果是长比特序列之间的运算，则只要对其中每个相对应的比特进行XOR运算就可以了。假设我们将01001100这个比特序列称为A，将10101010这个比特序列称为B，那么A与B的XOR运算就可以像下面这样逐一对各个比特进行计算。和加法运算不同的是，XOR中不需要进位。 由于两个相同的数进行XOR运算的结果一定为0，因此如果将A⊕B的结果再与B进行XOR运算，则结果会变回A。也就是说，两个公式中的B会相互抵消。 可能大家已经发现了，上面的计算和加密、解密的步骤非常相似。 将明文A用密钥B进行加密，得到密文A⊕B 将密文A⊕B用密钥B进行解密，得到明文A 实际上，只要选择一个合适的B，仅仅使用XOR就可以实现一个高强度的密码。 对同一个比特序列进行两次XOR之后就会回到最初的状态。 CBC模式 CBC(Cipher Block Chaining, 密码块链)模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密。 这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，第一个数据块进行加密之前需要用初始化向量IV进行异或操作。 CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。 如果将一个分组的加密过程分离出来，我们就可以很容易地比较出ECB模式和CBC模式的区别 。ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。 初始化向量 当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组“，这个比特序列称为初始化向量（initialization vector） 通常缩写为 IV 一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。 明文分组在加密之前一定会与“前一个密文分组”进行 XOR 运算，因此即便明文分组1和2的值是相等的，密文分组1和2的值也不一定是相等的。这样一来，ECB模式的缺陷在CBC模式中就不存在了。 3.4 CFB 模式 CFB模式的全称是Cipher FeedBack模式（密文反馈模式）。在CFB模式中，前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文。 所谓反馈，这里指的就是返回输人端的意思，即前一个密文分组会被送回到密码算法的输入端。 CFB模式的解密和CBC模式的加密在流程上其实是非常相似的。 在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。 从上图可以看出，明文分组和密文分组之间并没有经过”加密”这一步骤。在CFB模式中，明文分和密文分组之间只有一个XOR。 我们将CBC模式与CFB模式对比一下，就可以看出其中的差异了（如下图）。在CBC模式中，明文分组和密文分组之间有XOR和密码算法两个步骤，而在CFB模式中，明文分组和密文分组之间则只有XOR。 初始化向量 在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替，这一点和CBC模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。 CFB模式与流密码 CFB模式是通过将“明文分组”与“密码算法的输出”进行XOR运算来生成“密文分组”的。 在CFB模式中，密码算法的输出相当于一个随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此CFB模式不可能具各理论上不可破译的性质。 CFB模式中由密算法所生成的比特序列称为密钥流（key stream）。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量相当于伪随机数生成器的“种子“。 在CFB模式中，明文数据可以被逐比特加密，因此我们可以将CFB模式看做是一种使用分组密码来实现流密码的方式。 3.5 OFB 模式 OFB式的全称是Output-Feedback模式（输出反馈模式）。在OFB模式中，密码算法的输出会反馈到密码算法的输入中， 即上一个分组密码算法的输出是当前分组密码算法的输入（下图）。 OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将 “明文分组” 和 “密码算法的输出” 进行XOR来产生 “密文分组” 的，在这一点上OFB模式和CFB模式非常相似。 初始化向量 和CBC模式、CFB模式一样，OFB模式中也需要使用初始化向量（IV）。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。 CFB模式和OFB模式对比 OFB模式和CFB模式的区别仅仅在于密码算法的输入。 CFB式中，密码算法的输人是前一个密文分组，也就是将密文分组反馈到密算法中，因此就有了“密文反馈模式”这个名字。 相对地，OFB模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈给密码算法，因此就有了“输出反馈模式”这个名字。 如果将一个分组抽出来对CFB模式和OFB模式进行一个对比．就可以很容易看出它们之间的差异（下图）。 由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。 相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了。只要将明文与密钥流进行XOR就可以了。和AES等密码算法相比，XOR运算的速度是非常快的。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。 3.6 CTR 模式 CTR模式的全称是CounTeR模式（计数器模式）。CTR摸式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码（下图）。 CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。 计数器的生成方法 每次加密时都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器的初始值可能是像下面这样的形式。 其中前8个字节为nonce（随机数），这个值在每次加密时必须都是不同的，后8个字节为分组序号，这个部分是会逐次累加的。在加密的过程中，计数器的值会产生如下变化： 按照上述生成方法，可以保证计数器的值每次都不同。由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也是说，这种方法就是用分组密码来模拟生成随机的比特序列。 OFB模式与CTR模式对比 CTR模式和OFB模式一样，都属于流密码。如果我们将单个分组的加密过程拿出来，那么OFB模式和CTR模式之间的差异还是很容易理解的（下图）。OFB模式是将加密的输出反愦到输入，而CTR模式则是将计数器的值用作输入。 CTR模式的特点 CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。 此外，CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。 能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。 3.7 总结 我们已经介绍了ECB、CBC、CFB、OFB和CTR模式，下面我们对这些模式的特点做一下整理。","categories":[],"tags":[]},{"title":"2.对称加密（相同密钥加解密)---《图解密码学》","slug":"crypt-two-md","date":"2020-04-30T02:12:14.000Z","updated":"2022-05-28T19:11:59.836Z","comments":true,"path":"2020/04/30/crypt-two-md/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/04/30/crypt-two-md/","excerpt":"","text":"2.1 编码 现代的密码都是建立在计算机的基础之上的，这是因为现代的密码所处理的数据量非常大，而且密码算法也非常复杂，不借助计算机的力量就无法完成加密和解密的操作。 计算机的操作对象并不是文字，而是由0和1排列而成的比特序列。无论是文字、图像、声音、视频还是程序，在计算机中都是用比特序列来表示的。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。 将现实世界中的东西映射为比特序列的操作称为编码（encoding）。例如midnight（深夜）这个词，我们可以对其中的每个字母逐一进行编码，这种编码规则叫作ASCII。 注意这里的m –&gt; 01101101这一转换并不是加密而是编码。尽管在人类看来0和1的序列跟密码没什么两样，但计算机却可以“看懂”这些比特序列，并很快地反应出其所对应的字符 midnight 2.2 DES2.2.1 什么是DES DES（Data Encryption Standard）是1977年美国联邦信息处理标准（FIPS）中所采用的一种对称密码（FIPS46.3）。DES一直以来被美国以及其他国家的政府和银行等广泛使用。然而，随着计算机的进步，现在DES已经能够被暴力破解，强度大不如前了。 RSA公司举办过破泽DES密钥的比赛（DESChallenge），我们可以看一看RSA公司官方公布的比赛结果： 1997年的DES Challenge1中用了96天破译密钥 1998年的DES ChallengeIl-I中用了41天破译密钥 1998年的DES ChallengeII-2中用了56小时破译密钥 1999年的DES ChallengeIll中只用了22小时15分钟破译密钥 由于DES的密文可以在短时间内被破译，因此除了用它来解密以前的密文以外，现在我们不应该再使用DES了。 2.2.2 加密和解密 DES是一种将64比特的明文加密成64比特的密文的对称密码算法，它的密钥长度是56比特。尽管从规格上来说，DES的密钥长度是64比特，但由于每隔7比特会设置一个用于错误检查的比特，因此实质上其密钥长度是56比特。 DES是以64比特的明文（比特序列）为一个单位来进行加密的，这个64比特的单位称为分组。一般来说，以分组为单位进行处理的密码算法称为分组密码（blockcipher），DES就是分组密码的一种。 DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式就称为模式（mode）。 DES的加密与解密 - 图例 2.3 三重DES 现在DES已经可以在现实的时间内被暴力破解，因此我们需要一种用来替代DES的分组密码，三重DES就是出于这个目的被开发出来的。 三重DES（triple-DES）是为了增加DES的强度，将DES重复3次所得到的一种密码算法，通常缩写为3DES。 2.3.1 三重DES的加密 三重DES的加解密机制如图所示： 明文经过三次DES处理才能变成最后的密文，由于DES密钥的长度实质上是56比特，因此三重DES的密钥长度就是56×3=168比特, 加上用于错误检测的标志位8x3, 共192bit。 从上图我们可以发现，三重DES并不是进行三次DES加密（加密–&gt;加密–&gt;加密），而是加密–&gt;解密–&gt;加密的过程。在加密算法中加人解密操作让人感觉很不可思议，实际上这个方法是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES。 当三重DES中所有的密钥都相同时，三重DES也就等同于普通的DES了。这是因为在前两步加密–&gt;解密之后，得到的就是最初的明文。因此，以前用DES加密的密文，就可以通过这种方式用三重DES来进行解密。也就是说，三重DES对DES具备向下兼容性。 如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥（也就是只使用两个DES密钥），这种三重DES就称为DES-EDE2。EDE表示的是加密（Encryption) –&gt;解密（Decryption)–&gt;加密（Encryption）这个流程。 密钥1、密钥2、密钥3全部使用不同的比特序列的三重DES称为DES-EDE3。 尽管三重DES目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题。 2.4 AES AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码算法。全世界的企业和密码学家提交了多个对称密码算法作为AES的候选，最终在2000年从这些候选算法中选出了一种名为Rijndael的对称密码算法，并将其确定为了AES。 Rijndael是由比利时密码学家Joan Daemen和Vincent Rijmen设汁的分组密码算法，今后会有越来越多的密码软件支持这种算法。 Rijndael的分组长度为128比特，密钥长度可以以32比特为单位在128比特到256比特的范围内进行选择（不过在AES的规格中，密钥长度只有128、192和256比特三种）。 2.4.2 AES的加密和解密 和DES—样，AES算法也是由多个轮所构成的，下图展示了每一轮的大致计算步骤。DES使用Feistel网络作为其基本结构，而AES没有使用Feistel网络，而是使用了SPN Rijndael的输人分组为128比特，也就是16字节。首先，需要逐个字节地对16字节的输入数据进行SubBytes处理。所谓SubBytes,就是以每个字节的值（0～255中的任意值）为索引，从一张拥有256个值的替换表（S-Box）中查找出对应值的处理，也是说，将一个1字节的值替换成另一个1字节的值。 SubBytes之后需要进行ShiftRows处理，即将SubBytes的输出以字节为单位进行打乱处理。从下图的线我们可以看出，这种打乱处理是有规律的。 ShiftRows之后需要进行MixCo1umns处理，即对一个4字节的值进行比特运算，将其变为另外一个4字节值。 最后，需要将MixColumns的输出与轮密钥进行XOR，即进行AddRoundKey处理。到这里，AES的一轮就结東了。实际上，在AES中需要重复进行10 ~ 14轮计算。 通过上面的结构我们可以发现输入的所有比特在一轮中都会被加密。和每一轮都只加密一半输人的比特的Feistel网络相比，这种方式的优势在于加密所需要的轮数更少。此外，这种方式还有一个优势，即SubBytes，ShiftRows和MixColumns可以分别按字节、行和列为单位进行并行计算。 SubBytes – 字节代换 ShiftRows – 行移位代换 MixColumns – 列混淆 AddRoundKey – 轮密钥加 下图展示了AES中一轮的解密过程。从图中我们可以看出，SubBytes、ShiftRows、MixColumns分别存在反向运算InvSubBytes、InvShiftRows、InvMixColumns，这是因为AES不像Feistel网络一样能够用同一种结构实现加密和解密。 InvSubBytes – 逆字节替代 InvShiftRows – 逆行移位 InvMixColumns – 逆列混淆 2.5 应选择哪种对称加密 前面我们介绍了DES、三重DES和AES等对称密码，那么我们到底应该使用哪一种对称密码算法呢？ 今后最好不要将DES用于新的用途，因为随着计算机技术的进步，现在用暴力破解法已经能够在现实的时间内完成对DES的破译。但是，在某些情况下也需要保持与旧版本软件的兼容性。 出于兼容性的因素三重DES在今后还会使用一段时间，但会逐渐被AES所取代。 今后大家应该使用的算法是AES（Rijndael），因为它安全、快速，而且能够在各种平台上工作。此外，由于全世界的密码学家都在对AES进行不断的验证，因此即便万一发现它有什么缺陷，也会立刻告知全世界并修复这些缺陷。 一般来说，我们不应该使用任何自制的密码算法，而是应该使用AES。因为AES在其选定过程中，经过了全世界密码学家所进行的高品质的验证工作，而对于自制的密码算法则很难进行这样的验证。 本章小结 本章中我们介绍了对称密码，以及DES、三重DES、AES和其他一些密码算法。 使用一种密钥空间巨大，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的机密性。巨大的密钥空间能够抵御暴力破解，算法上没有弱点可以抵御其他类型的攻击。 然而，用对称密码进行通信时，还会出现密钥的配送问题，即如何将密钥安全地发送给接收者。为了解决密钥配送问题，我们需要非对称加密技术 本章所介绍的几乎所有的密码算法，都只能将一个固定长度的分组进行加密当需要加密的明文长度超过分组长度时，就需要对密码算法进行迭代下一章我们将探讨对分组密码进行迭代的方法。","categories":[],"tags":[]},{"title":"1.密码学 ---《图解密码学》","slug":"crypt-one-md","date":"2020-04-29T01:11:14.000Z","updated":"2022-05-28T19:11:40.113Z","comments":true,"path":"2020/04/29/crypt-one-md/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/04/29/crypt-one-md/","excerpt":"","text":"常用密码技术1.密码1.1 发送者、接收者和窃听者 假设Alice向Bob发送消息。在这个场景中，发出消息的Alice称为 发送者（sender），而收到消息的Bob则称为 接收者（receiver）。 Alice向Bob发送邮件 消息在互联网上传输的时候，可能被恶意窃听者窃听偷看到。 Eve（窃听者）看到消息的内容 裸露的消息内容原本应该只有发送者和接收者两个人知道，但是在传输的过程中就存在被第三方知道的风险。 1.2 加密和解密 Alice不想让别人看到消息的内容，于是可以对消息进行加密（encrypt）后再发送出去。 加密之前的消息称为明文（plaintext），加密之后的消息称为密文（cipher-text）。 Bob收到了来自Alice的加密消息，于是Bob需要对密文进行解密（decrypt）之后再阅读。 密文解密之后就变成了原来的明文 将消息加密后发送, 窃听者只能得到密文 1.3 秘钥1.3.1 密码算法 把明文加密成密文的过程,称为“加密算法”,而密文解密成明文的过程，称为“解密算法”。加密、解密的算法合在一起统称为密码算法。 1.3.2 秘钥 密码算法中需要密钥（key）。就如同现实生活中的钥匙一样，我们要打开锁，必须要用匹配的钥匙。 使用密钥进行加密、解密 1.4 密码信息安全常识与威胁1.4.1 信息安全常识 不要使用保密的密码算法 使用低强度的密码比不进行任何加密更危险 任何密码总有一天都会被破解 密码只是信息安全的一部分 不要使用保密的密码算法 这样做的原因主要有以下两点： 密码算法的秘密早晚会公诸于世 从历史上看，密码算法的秘密最终都会被暴露出来。例如: RSA公司开发的RC4密码算法曾经也是保密的，但最终还是有一位匿名人士开发并公开了与其等效的程序。 公开的算法从一开始就没有设想过要保密，因此算法的暴露丝毫不会削弱它们的强度。 开发高强度的密码算法是非常困难的 要比较密码算法的强弱是极其困难的，因为密码算法的强度并不像数学那样可以进行严密的证明。密码算法的强度只能通过事实来证明，如果专业密码破译者经过数年的尝试仍然没有破解某个密码算法，则说明这种算法的强度较高。 现在世界上公开的被认为强度较高的密码算法，几乎都是经过密码破译者长期尝试破解未果而存活下来的 试图通过对密码算法本身进行保密来确保安全性的行为，一般称为隐蔽式安全性（securitybyobscurity），这种行为是危险且愚蠢的。 反过来说，将密码算法的详细信息以及程序源代码全部交给专业密码破译者，并且为其提供大量的明文和密文样本，如果在这样的情况下破译一段新的密文依然需要花上相当长的时间，就说明这是高强度的密码。 使用低强度的密码比不进行任何加密更危险 一般我们会认为．就算密码的强度再低，也比完全不加密要强吧？其实这样的想法是非常危险的。 正确的想法应该是：与其使用低强度的密码，还不如从一开始就不使用任何密码这主要是由于用户容易通过“密码”这个词获得一种“错误的安全感”。对于用户来说，安全感与密码的强度无关，而只是由“信息已经被加密了”这一事实产生的，而这通常会导致用户在处理一些机密信息的时候麻痹大意。 任何密码总有一天会被破译 如果某种密码产品宣称“本产品使用了绝对不会被破解的密码算法”，那么你就要对这个产品的安全性打个问号了，这是因为绝对不会被破解的密码是不存在的。 无论使用任何密码算法所生成的密文，只要将所有可能的密钥全部尝试一遍，就总有一天可以破译出来。因此，破译密文所需要花费的时间，与要保密的明文的价值之间的权衡就显得非常重要。 密码只是信息安全的一部分 我们还是回到Alice给Bob发送加密消息的例子。即便不去破解密码算法，也依然有很多方法能够知道Alice所发送的邮件内容, 例如: 攻击者可以不去试图破译经过加密的邮件，而是转而攻击Alice的电脑以获取加密之前的邮件明文。 上面提到的攻击手段，都与密码的强度毫无关系。要保证良好的安全性，就需要理解“系统”这一概念本身的性质复杂的系统就像一根由无数个环节相连组成的链条，如果用力拉，链条就会从其中最脆弱的环节处断开。因此，系统的强度取决于其中最脆弱的环节的强度。 最脆弱的环节并不是密码，而是人类自己。 1.4.2 密码信息威胁 我们将信息安全所面临的威胁与用来用对这些威胁的密码技术直接的关系用一张图标来表示出来。","categories":[],"tags":[]},{"title":"iOS 90%人可能都会回答错误的一个多线程基础题","slug":"ios-gcd-ptread","date":"2020-03-27T09:55:23.000Z","updated":"2022-05-01T11:29:51.755Z","comments":true,"path":"2020/03/27/ios-gcd-ptread/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/03/27/ios-gcd-ptread/","excerpt":"","text":"题目描述： 一问：GCD是同步还是异步情况会开启多线程 答：同步是不会开启新的线程的，异步才会开启新的线程。 这个没啥难度，基本都是必会的。通过代码验证同步在串行队列和并发队列情况下会不会创建新的线程 验证代码： 12345678910dispatch_queue_t serialQueue = dispatch_queue_create(\"serialQueue\", DISPATCH_QUEUE_SERIAL);dispatch_queue_t conQueue = dispatch_queue_create(\"conQueue\", DISPATCH_QUEUE_CONCURRENT);NSLog(@\"(1).=====%@\",[NSThread currentThread]);dispatch_sync(serialQueue, ^&#123; NSLog(@\"(2).=====%@\",[NSThread currentThread]);&#125;);dispatch_sync(conQueue, ^&#123; NSLog(@\"(3).=====%@\",[NSThread currentThread]);&#125;); 输出结果： 123(1).=====&lt;NSThread: 0x2837f6f00&gt;&#123;number = 1, name = main&#125;(2).=====&lt;NSThread: 0x2837f6f00&gt;&#123;number = 1, name = main&#125;(3).=====&lt;NSThread: 0x2837f6f00&gt;&#123;number = 1, name = main&#125; 可以看出同步是不会产生新的线程。当然问题肯定不会这么简单就结束了。 二问：异步一定会开启新的线程吗。 答：不会，异步在主队列里不会创建新的线程，在其他串行和并发队列都会创建新的子线程 验证代码： 1234567891011121314dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_queue_t serialQueue = dispatch_queue_create(\"serialQueue\", DISPATCH_QUEUE_SERIAL);dispatch_queue_t conQueue = dispatch_queue_create(\"conQueue\", DISPATCH_QUEUE_CONCURRENT);NSLog(@\"(1).=====%@\",[NSThread currentThread]);dispatch_async(serialQueue, ^&#123; NSLog(@\"(2).=====%@\",[NSThread currentThread]);&#125;);dispatch_async(conQueue, ^&#123; NSLog(@\"(3).=====%@\",[NSThread currentThread]);&#125;);dispatch_async(mainQueue, ^&#123; NSLog(@\"(4).=====%@\",[NSThread currentThread]);&#125;); 输出结果： 1234(1).=====&lt;NSThread: 0x2800a6f00&gt;&#123;number = 1, name = main&#125;(2).=====&lt;NSThread: 0x2800ca5c0&gt;&#123;number = 3, name = (null)&#125;(3).=====&lt;NSThread: 0x2800ca5c0&gt;&#123;number = 3, name = (null)&#125;(4).=====&lt;NSThread: 0x2800a6f00&gt;&#123;number = 1, name = main&#125; 看结果(1)和(4)可以确定，在异步主队列确实没有开启新的线程，两个都是main线程，number号为1. 再看(2)和(3)，发现确实是创建了新的线程。但是仔细看线程号 发现（2）和（3） 对应的 number 都是3 。也就是这两个异步动作只创建了一个新的线程。按照常识来说不是应该创建两个不同线程吗？ 这儿就要从时间和空间谈到GCD对线程调度优化问题了。 GCD在执行多个异步操作的时候，会从时间和空间进行权衡会不会创建新的线程，一般每一个任务开启一个线程这样时间最优，但是线程太多会消耗内存空间。所以GCD会自动权衡根据任务分配合适的线程数，从而达到空间和时间的最优。 当然具体GCD是怎么做的，可能需要看源码了… 这是我给这个问题的总结： 同步：不具备开启线程的能力，一定串行执行任务 异步：具有开启线程的能力，但是在主队列里不会开启新的线程。如果在串行队列和并发队列里开启n个子线程，gcd优化之后未必会真的有n个子线程。","categories":[],"tags":[]},{"title":"如何判断机器的字节顺序是高字节在前还是低字节在前","slug":"how-to-know-highorlow-computer-md","date":"2020-01-27T09:55:23.000Z","updated":"2022-05-09T14:23:38.160Z","comments":true,"path":"2020/01/27/how-to-know-highorlow-computer-md/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2020/01/27/how-to-know-highorlow-computer-md/","excerpt":"","text":"经常听各种人在群里面讨论各种机，linux，mac，windows，单片机的啥都有。讨论的焦点就是在这些机器上到底是高字节在前还是低字节在前。其实这个问题是很简单，只要稍微懂一点c语言知识。对，只要知道如何使用指针就可以做出正确的判断了。甚至你也许连指针都不会也没关系。只要你的电脑上有一个c的编译器，随便百度或者google以下判断的代码，拷贝黏贴上去，然后在运行一下，什么问题都可以搞定了 123456789101112#include &lt;stdio.h&gt;int main() &#123; int x = 1; if(*(char *)&amp;x == 1) printf(\"低字节在前\\n\"); else printf(\"高字节在前\\n\"); return 0;&#125; 本机的运行结果： 代码解释说明： 1是整型，在不同机器上，可能是16位，也可能是32位，即2字节或4字节。假设是4字节。(如图左边是高字节，右边是低字节) C语言中只有char是单字节数据，所以，只有通过(char )地址这种方式，才能查看某个确切地址空间上的数据。 在低字节在前的机器上，1在内存空间中的二进制形式是 这时候令x=1的话，&amp;x是x的地址，即指向0x01这个字节，通过 (char )&amp;x得到的是1。在高字节在前的机器上，1在内存中是 &amp;x指向的是0x00这个字节，(char )&amp;x得到的0","categories":[],"tags":[]},{"title":"【译】Swift和函数式编程的精髓","slug":"swift-function-program","date":"2019-10-11T01:58:08.000Z","updated":"2022-05-02T05:51:49.850Z","comments":true,"path":"2019/10/11/swift-function-program/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2019/10/11/swift-function-program/","excerpt":"","text":"我想说这真的是一篇非常非常好的文章，它通过对一个实例的API的优化，教会我们如何写出优美简洁的Swift的函数式代码。但是这个文章是视频中作者的口述，所以翻译过程中难免有不当之处。大家可以对着视频和原文进行观看和对比。 原文地址 介绍Swift第一次被公布的一周后，我写了一篇名为“Swift不是函数式”的博文。两年后，Swift仍然不是函数式。这篇文章并没有对此进行阐述，而是将讨论函数式语言几十年来的经验和研究，我们可以用自己快速的方式将这些经验和研究带入Swift。 什么是函数式编程它是单子、仿函数、haskell和优雅的代码。 函数式编程不是一种语言或语法，而是一种思考问题的方式。函数式编程在我们有单子之前已经存在了几十年。函数式编程是一种思考如何分解问题，然后以结构化的方式将它们重新组合在一起的方法。 让我们从swift中的一个简单示例开始。 1234567var persons: [Person] = []for name in names &#123; let person = Person(name: name) if person.isValid &#123; persons.append(person) &#125;&#125; 这是一个简单的循环，它做两件事：将name转换成Person，然后将这些人放入一个有效的数组中。很简单，但这里有很多事情。为了理解发生了什么，你需要在头脑中执行这个。你需要思考，“这个数组是做什么的？“ 它看起来很简单，但可能会更简单。我们可以把问题分开。我们可以把东西拆开。我们现在有两个循环，每个循环做的更少。每一个都很简单，更简单的代码让我们找到模式：创建一个数组，遍历一些值，对每个值执行一些操作，然后在最后将它们放到另一个数组中。 当你有一些事情做了很多次，你可能应该提取函数-Swift有一个，它被称为map。map将某物的列表转换为其他某物的列表。重要的是它说明了它的含义：可能persons是names到person的映射。这是一份根据人名列出的名单。我们不必在头脑中执行任何东西，他就在代码中表述我们的意思。 12let possiblePersons = names.map(Person.init)let persons = possiblePersons.filter &#123; $0.isValid &#125; 另一个循环也是一个非常常见的模式：它有一个名为“filter”的方法。filter接受一个谓词，它是一个返回bool的函数。它使用函数给我们返回有效的数据。我们可以把这些结合在一起，从而获得possiblePersons，然后把他们加入我们的过滤器。 从七行代码到两行代码。另外，我们可以重新组合它们：这些都是我们可以重新组合起来的值。我们用链式把他们进行组合。 它很容易阅读，我们可以一行一行地阅读。 123let persons = names .map(Person.init) .filter &#123; $0.isValid &#125; 它十分易学并且很容易适应这种方式。在这样的例子中你不必再写一个for循环了。 函数式工具1977年，John Backus（协助发明了Fortran 和 Algol）获得了图灵奖，发表演讲“编程能从冯诺依曼风格中解放出来吗？“我喜欢这个标题。“冯·诺依曼风格”是指Fortran和Algol。 这篇论文是他为发明它们而做的声明。他表示命令式编程，一步一步地改变某种状态，直到获得你想要的最终状态。当他说“函数式”的时候，那并不是指我们今天所说的函数式，但他启发了许多函数式研究人员去研究和学习。 这篇论文引起了我的兴趣，我们可以回到swift：我们如何将复杂的事情分解成简单的事情。把这些简单的东西泛化，然后用一些规则把它们粘在一起，比如代数。 代数是一套规则，用来把事物组合在一起，把它们拆开，然后转换它们。我们可以想出可以用来操纵程序的规则。我们已经做到了：我们做了一个循环，我们把它分解成两个简单的循环，找到每一个循环的通用形式，然后使用链式将它们重新组合在一起。当haskell程序员第一次遇到swift时，他们往往会感到沮丧，因为试着做它们在Haskell语言中做的事。 在haskell中，与几乎所有的函数式语言一样，组成的基本单元是函数。有很多漂亮的方法来组合函数。我可以通过将foldr函数和+函数粘合在一起，并将其初始值设为0，来创建一个名为sum的新函数。不管你读起来是否舒服，只要你这样做了，它就相当漂亮了。 12let sum = foldr (+) 0 sum [1..10] 你可以用swift来做，但是它会很难看，而且它不能很好地工作，因为你在用错误单元组合它们。swift不是函数式。 swift中的组成单位是类型。类、结构、枚举和协议，这些都是可以组合的。我们通常把两种类型粘在一起。通过实现一个函数并将它们粘在一起，我们可以用更简单的片段来构建它们。 swift中另一种非常常见的构图是将类型放在语境中。你最常用的是optionals。可选类型是根据语境确定的，在语境中可能有值也可能没有值。这是一个与类型相关的小信息：它是否存在？这就是语境的含义。添加语境比其他跟踪额外信息的方法强大得多。 1234extension MyStruct&lt;T&gt;: Sequence &#123; func makeIterator() -&gt; AnyIterator&lt;T&gt; &#123;return ... &#125;&#125; 我们可以跟踪一个事实，即不存在整数，或者根本不存在值，这是因为我们会从-1这样的整数中窃取一个值，这意味着没有值。但是现在你必须到处测试，这是丑陋的，容易出错的，编译器不能帮你。 如果我们将整数改为可选的，这时编译器可以帮助您。你有这样的语境“它存在吗，它不存在吗，我可以帮助你确保你不会忘记这一点。”如果你曾经使用过-1，很容易忘记检查，然后你的程序变得不可控了。 例子让我们建立一个更复杂的例子。 123456789func login(username: String, password: String, completion: (String?, Error?) -&gt; Void)login(username: \"rob\", password: \"s3cret\") &#123; (token, error) in if let token = token &#123; // success &#125; else if let error = error &#123;// failure &#125;&#125; 这是一个非常常见的API。我们有一个带有username和password参数的login函数，在某个时刻，它将返回一个token和一个可能的错误。我认为我们可以通过考虑语境做得更好。 第一个问题 是这个completion。我说它是一个string，是什么样的string。她是一个token.我可以给它贴个标签，但那没用。在swift中，标签不是类型的一部分。即使我这么做了，还是这个string。字符串可以是指很多东西。 Tokens有规则：例如，它们可能必须是固定长度，或者不能为空。这些都是可以用字符串做的，但不能用tokens。我们希望有更多关于token的上下文；它有规则，所以我们希望捕获这些规则。我们可以做到，我们可以给它更多的结构。这就是为什么它被称为struct。 123struct Token &#123; let string: String&#125; 我把字符串放入结构体中。这不会花费任何成本，也不会导致间接或任何额外的内存使用，但现在我可以对此设置规则。 你只能用特定的字符串来构造它们。我可以在上面加上一些扩展，这样就没有必要用任意的字符串了。这要好多了，我可以对所有类型都这样做；字符串当然没问题，也可以是字典、数组和整数类型。 当您拥有这些类型时，您可以将它们提升到上下文中，并控制可以放在它们上的内容。你可以控制他表达的意思。我不需要标签或注释，因为第一个参数显然是一个token，因为它的类型是Token。 第二个问题 是我们要传递username和password。在大多数有这些的程序中，您总是将它们一起传递；password本身尤其无用。我想创建一个规则，允许我用“and”组合用户名和密码，所以我需要一个“and”类型。我们有一个，它又是一个结构。 “AND”类型1234struct Credential &#123; var username: String var password: String&#125; 结构体是”and”类型。 Credential 是由username和password组成. “and”类型被称为 “生产类型”.我鼓励你大声说出来。例如：“凭证是用户名和密码。”这有意义吗？如果它没有意义，也许它是错误的类型，或者你创建它是错误的。 123456789101112func login(credential: Credential, completion: (Token?, Error?) -&gt; Void)let credential = Credential(username: \"rob\", password: \"s3cret\")login(credential: credential) &#123; (token, error) in if let token = token &#123; // success &#125; else if let error = error &#123;// failure &#125;&#125; 现在我们可以交换Credential，而不是username和password：这也使得我们的签名更短更清晰。我们还提供了许多不错的可能性：在Credentials上添加扩展，在其他类型的规则下交换它们。也许我们想要10次password，或者access token，或者facebook或者google等等。现在，我不需要更改代码的任何其他部分，因为我只是传递credentials。 不过，它也有问题。我们通过了元组(Token?, Error?) –元组是“and”类型。它们是匿名结构。我们的意思是“也许是token，也许是error”？有四种可能性：两者都有，或者两者都没有，或者一个或另一个。只有两种可能性是有意义的。如果我得到了一个token和error？这是一个错误条件吗？我需要一个致命的错误吗？我需要忽略它吗？你需要考虑一下这个问题，并可能针对它编写测试。 “OR” Type (Sum)问题是你不是说“也许”什么的-你是指一个token或一个error。我们有可以使用的“或”类型吗？ 1234enum Result&lt;Value&gt; &#123; case success(Value) case failure(Error)&#125; It is an enum - enums are “or” types (this or that), whereas structs are “and” types (this and that). Like “and” types are called “product types”, “or” types are called “sum types”.这是一个枚举 - enums是 “or”类型，就像结构体是“and”类型。正如“and”类型被称作“生产类型”，“or”类型被称为“和类型” 12345678func login(credential: Credential, completion: (Result&lt;Token&gt;) -&gt; Void)login(credential: credential) &#123; result in switch result &#123; case .success(let token): // success case .failure(let error): // failure &#125;&#125; 我想建立这个result类型。这让我很困扰，因为它不是内置在swift中的。它很容易建造。我们将提升我们的值，给它更多的语境。它从一种值转变为一个成功的值。 我们的错误变成一个失败的错误，我们有更多的语境。如果我们将result、生成的token扔进我们的api中，那么我们必须针对所有这些情况编写测试来保证所有不可能的情况都会消失。我们不必担心他们，因为他们是不可能的。我希望错误不可能，而不是编写测试用例。 我喜欢这个API。我用credential登录，它会给我一个生成的token。 这个课程这是函数式编程的真正精髓，也是我们应该带给swift的：复杂的事情可以分解成更小、更简单的事情。 我们可以为这些简单的事情找到通用的解决方案，我们可以使用一致的规则将这些简单的事情重新组合起来，让我们对我们的程序进行推理。这使得编译器更容易查出bug，我认为70年代的John Backus完全同意这一点。把它拆了，把它造起来。","categories":[],"tags":[]},{"title":"【译】如何在swift中使用函数式编程","slug":"how-to-use-functional-program-in-swift","date":"2019-10-03T13:50:34.000Z","updated":"2022-05-02T05:51:49.849Z","comments":true,"path":"2019/10/03/how-to-use-functional-program-in-swift/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2019/10/03/how-to-use-functional-program-in-swift/","excerpt":"","text":"翻译：https://www.raywenderlich.com/9222-an-introduction-to-functional-programming-in-swift#toc-anchor-012 在本教程中，您将逐步学习如何开始使用函数式编程以及如何编写声明性代码而不是命令式代码。 swift于2014年在WWDC上进入编程世界的大门，它不仅仅是一门新的编程语言。 它为iOS和macOS平台的软件开发提供了便利。 本教程重点介绍其中一种方法：函数式编程，简称FP。 您将了解FP中使用的各种方法和技术。 开始创建一个新的playground通过选择File ▸ New ▸ Playground设置你的playground，通过拖拽分割线你可以看到结果面板和控制台 现在删除playground中所有代码，添加一下行： 1import Foundation 开始在大脑中回忆一些基础理论吧。 命令式编程风格当你第一次学习编码时，你可能学会了命令式的风格。 命令式风格如何运作？添加下面代码到你的playground: 123var thing = 3//some stuffthing = 4 该代码是正常和合理的。 首先，你创建一个名为thing的变量等于3，然后你命令thing变为4。 简而言之,这就是命令式的风格。 您使用一些数据创建变量，然后将该变量改为其他数据。 函数式编程概念在本节中，您将了解FP中的一些关键概念。 许多论文表明immutable state(状态不变)和lack of side effects(没有副作用)是函数式编程两个最重要的特征，所以你将先学习它们。 不变性和副作用无论您首先学习哪种编程语言，您可能学到的最初概念之一是变量代表数据或状态。 如果你退一步思考这个想法，变量看起来很奇怪。 术语“变量”表示随程序运行而变化的数量。 从数学角度思考数量thing，您已经将时间作为软件运行方式的关键参数。 通过更改变量，可以创建mutable state(可变状态)。 要进行演示，请将此代码添加到您的playground： 12345678func superHero() &#123; print(\"I'm batman\") thing = 5&#125;print(\"original state = \\(thing)\")superHero()print(\"mutated state = \\(thing)\") 神秘变化！为什么thing变成5了？这种变化被称为** side effect **。函数superHero（）更改了一个它自己没有定义的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时会出现问题，例如在大型面向对象系统中。可变状态可能会让人很难理解变量的值以及该值随时间的变化。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一个变量，它们可能会无序地修改或访问它。这会导致意外行为。这种意外行为包括竞争条件，死锁和许多其他问题。 想象一下，如果你可以编写状态永远不会发生变化的代码。并发系统中出现的一大堆问题将会消失。像这样工作的系统具有不可变状态，这意味着不允许状态在程序的过程中发生变化。 使用不可变数据的主要好处是使用它的代码单元没有副作用。代码中的函数不会改变自身之外的元素，并且在发生函数调用时不会出现任何怪异的效果。您的程序可以预测，因为没有副作用，您可以轻松地重现其预期的效果。 本教程涵盖了高级的FP编程，因此在现实世界中考虑概念是有帮助的。在这种情况下，假设您正在构建一个游乐园的应用程序，并且该游乐园的后端服务器通过REST API提供数据。 创建游乐园的模型通过添加以下代码到playground去创建数据结构 123456789101112131415161718192021222324enum RideCategory: String, CustomStringConvertible &#123; case family case kids case thrill case scary case relaxing case water var description: String &#123; return rawValue &#125;&#125;typealias Minutes = Doublestruct Ride: CustomStringConvertible &#123; let name: String let categories: Set&lt;RideCategory&gt; let waitTime: Minutes var description: String &#123; return \"Ride –\\\"\\(name)\\\", wait: \\(waitTime) mins, \" + \"categories: \\(categories)\\n\" &#125;&#125; 接着通过model创建一些数据： 12345678910111213141516let parkRides = [ Ride(name: \"Raging Rapids\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"Crazy Funhouse\", categories: [.family], waitTime: 10.0), Ride(name: \"Spinning Tea Cups\", categories: [.kids], waitTime: 15.0), Ride(name: \"Spooky Hollow\", categories: [.scary], waitTime: 30.0), Ride(name: \"Thunder Coaster\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"Grand Carousel\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"Bumper Boats\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"Mountain Railroad\", categories: [.family, .relaxing], waitTime: 0.0)] 当你声明parkRides通过let代替var,数组和它的内容都不可变了。尝试通过下面代码修改数组中的一个单元： 12parkRides[0] = Ride(name: \"Functional Programming\", categories: [.thrill], waitTime: 5.0) 产生了一个编译错误，是个好结果。你希望Swift编译器阻止你改变数据。现在删除错误的代码继续教程。 模块化使用模块化就像玩儿童积木一样。 你有一盒简单的积木，可以通过将它们连接在一起来构建一个庞大而复杂的系统。 每块砖都有一份工作，您希望您的代码具有相同的效果。 假设您需要一个按字母顺序排列的所有游乐设施名称列表。 从命令性地开始这样做，这意味着利用可变状态。 将以下功能添加到playground的底部： 1234567891011121314151617181920212223242526272829func sortedNamesImp(of rides: [Ride]) -&gt; [String] &#123; // 1 var sortedRides = rides var key: Ride // 2 for i in (0..&lt;sortedRides.count) &#123; key = sortedRides[i] // 3 for j in stride(from: i, to: -1, by: -1) &#123; if key.name.localizedCompare(sortedRides[j].name) == .orderedAscending &#123; sortedRides.remove(at: j + 1) sortedRides.insert(key, at: j) &#125; &#125; &#125; // 4 var sortedNames: [String] = [] for ride in sortedRides &#123; sortedNames.append(ride.name) &#125; return sortedNames&#125;let sortedNames1 = sortedNamesImp(of: parkRides) 你的代码完成了以下工作： 创建一个变量保存排序的rides 遍历传入函数的rides 使用插入排序排序rides 遍历排序的rides获得名称 添加下面代码到playground验证函数是否按照意图执行： 123456789101112131415func testSortedNames(_ names: [String]) &#123; let expected = [\"Bumper Boats\", \"Crazy Funhouse\", \"Grand Carousel\", \"Mountain Railroad\", \"Raging Rapids\", \"Spinning Tea Cups\", \"Spooky Hollow\", \"Thunder Coaster\"] assert(names == expected) print(\"✅ test sorted names = PASS\\n-\")&#125;print(sortedNames1)testSortedNames(sortedNames1) 现在你知道如果将来你改变排序的方式（例如：使其函数式），你可以检测到任何发生的错误。从调用者到sortedNamesImp(of:)的角度看，他提供了一系列的rieds,然后输出按照名字排序的列表。sortedNamesImp(of:)之外的任何东西都没有改变。你可以用另一个测试证明这点，将下面代码添加到playground底部： 1234567891011121314151617181920var originalNames: [String] = []for ride in parkRides &#123; originalNames.append(ride.name)&#125;func testOriginalNameOrder(_ names: [String]) &#123; let expected = [\"Raging Rapids\", \"Crazy Funhouse\", \"Spinning Tea Cups\", \"Spooky Hollow\", \"Thunder Coaster\", \"Grand Carousel\", \"Bumper Boats\", \"Mountain Railroad\"] assert(names == expected) print(\"✅ test original name order = PASS\\n-\")&#125;print(originalNames)testOriginalNameOrder(originalNames) 在这个测试中，你将收集作为参数传递的游乐设施列表的名称，并根据预期的顺序测试该订单。在结果区和控制台中，你将看到sortedNamesImp(of:)内的排序rides不会影响输入列表。你创建的模块化功能是半函数式的。按照名称排序rides是逻辑单一，可以测试的，模块化的并且可重复利的函数。sortedNamesImp(of:)中的命令式代码用于长而笨重的函数。该功能难以阅读，你无法轻易知道他干了什么事情。在下一部分你将学习如何进一步简化sortedNamesImp(of:)等函数中的代码。 一等和高阶函数在FP语言中，函数式一等公民。你可以把函数当成对象那样那样进行赋值。因此，函数可以接收其他函数作为参数或者返回值。接受或者返回其他函数的函数成为高阶函数。在本节中，你将使用FP语言中的三种常见的高阶函数：filter,map,reduce. Filter在swift中，filter是Collection类型的方法，例如Swift数组。它接受另一个函数作为参数。此另一个函数接受来自数组的单个值作为输入，检查该值是否属于并返回Bool.filter将输入函数应用于调用数组的每个元素并返回另一个数组。输出函数仅包含参数函数返回true的数组元素。试试下面的例子： 123let apples = [\"🍎\", \"🍏\", \"🍎\", \"🍏\", \"🍏\"]let greenapples = apples.filter &#123; $0 == \"🍏\"&#125;print(greenapples) 在输入数组中有三个青苹果，你将看到输出数组中含有三个青苹果。回想一下你用sortedNamesImp(of:)干了什么事情。 遍历所有的rides传递给函数的。 通过名字排序rides 获取已排序的riedes的名字 不要过分的考虑这一点，而是以声明的方式思考它，即考虑你想要发生什么而不是如何发生。首先创建一个函数，该函数将Ride对象作为函数的输入参数： 123func waitTimeIsShort(_ ride: Ride) -&gt; Bool &#123; return ride.waitTime &lt; 15.0&#125; 这个函数waitTimeIsShort(_:)接收一个Ride，如果ride的等待时间小于15min返回true，否则返回false。parkRides调用filter并且传入刚刚创建的函数。 12let shortWaitTimeRides = parkRides.filter(waitTimeIsShort)print(\"rides with a short wait time:\\n\\(shortWaitTimeRides)\") 在playground输出中，你只能在调用filter(_:)的输出中看到Crazy Funhouse和Mountain Railroad,这是正确的。由于swift函数也被叫闭包，因此可以通过将尾随闭包传递给过滤器并且使用闭包语法来生成相同的结果： 12let shortWaitTimeRides2 = parkRides.filter &#123; $0.waitTime &lt; 15.0 &#125;print(shortWaitTimeRides2) 这里，filter(_:)让$0代表了parkRides中的每个ride，查看他的waitTime属性并且测试它小于15min.你声明性的告诉程序你希望做什么。在你使用的前几次你会觉得这样很神秘。 Map集合方法map（_:）接受单个函数作为参数。在将该函数应用于集合的每个元素之后，它输出一个相同长度的数组。映射函数的返回类型不必与集合元素的类型相同。 试试这个： 12let oranges = apples.map &#123; _ in \"🍊\" &#125;print(oranges) 你把每一个苹果都映射成一个橘子，制作一个橘子盛宴。您可以将map（_:）应用于parkrides数组的元素，以获取所有ride名称的字符串列表： 123let rideNames = parkRides.map &#123; $0.name &#125;print(rideNames)testOriginalNameOrder(rideNames) 您已经证明了使用map（_:）获取ride名称与在集合使用迭代操作相同，就像您之前所做的那样。当你使用集合类型上sorted（by:）方法执行排序时，也可以按如下方式排序ride的名称： 1print(rideNames.sorted(by: &lt;)) 集合方法sorted（by:）接受一个比较两个元素并返回bool作为参数的函数。因为运算符&lt;是一个牛逼的函数，所以可以使用swift缩写的尾随闭包{$0&lt;$1}。swift默认提供左侧和右侧。 现在，您可以将提取和排序ride名称的代码减少到只有两行，这要感谢map（:）和sorted（by:）。使用以下代码将sortedNamesImp(_:)重新实现为sortedNamesFP(_:)： 1234567func sortedNamesFP(_ rides: [Ride]) -&gt; [String] &#123; let rideNames = parkRides.map &#123; $0.name &#125; return rideNames.sorted(by: &lt;)&#125;let sortedNames2 = sortedNamesFP(parkRides)testSortedNames(sortedNames2) 你的声明性代码更容易阅读，你可以轻松地理解它是如何工作的。测试证明sortedNamesFP(_:)和sortedNamesImp(_:).做了相同的事情。 Reduce集合方法reduce（::）接受两个参数：第一个是任意类型T的起始值，第二个是一个函数，该函数将同一T类型的值与集合中的元素组合在一起，以生成另一个T类型的值。输入函数一个接一个地应用于调用集合的每个元素，直到它到达集合的末尾并生成最终的累积值。例如，您可以将这些桔子还原为一些果汁： 12let juice = oranges.reduce(\"\") &#123; juice, orange in juice + \"🍹\"&#125;print(\"fresh 🍊 juice is served – \\(juice)\") 从空字符串开始。然后为每个桔子的字符串添加🍹。这段代码可以为任何数组注入果汁，因此请小心放入它：]。为了更实际，添加以下方法，让您知道公园中所有游乐设施的总等待时间。 1234let totalWaitTime = parkRides.reduce(0.0) &#123; (total, ride) in total + ride.waitTime &#125;print(\"total wait time for all rides = \\(totalWaitTime) minutes\") 此函数的工作方式是将起始值0.0传递到reduce中，并使用尾随闭包语法来添加每次骑行占用的总等待时间。代码再次使用swift简写来省略return关键字。默认情况下，返回total+ride.waittime的结果。在本例中，迭代如下： 12345Iteration initial ride.waitTime resulting total 1 0 45 0 + 45 = 45 2 45 10 45 + 10 = 55 … 8 200 0 200 + 0 = 200 如您所见，得到的总数将作为下一次迭代的初始值。这将一直持续，直到reduce迭代了parkRides中的每个Ride。这允许你用一行代码得到总数！ 先进技术您已经了解了一些常见的FP方法。现在是时候用更多的函数理论来做进一步的研究了。 Partial Functions（局部函数）部分函数允许您将一个函数封装到另一个函数中。要了解其工作原理，请将以下方法添加到playground： 12345func filter(for category: RideCategory) -&gt; ([Ride]) -&gt; [Ride] &#123; return &#123; rides in rides.filter &#123; $0.categories.contains(category) &#125; &#125;&#125; 这里，filter（for:）接受一个ridecategory作为其参数，并返回一个类型为（[Ride]）-&gt;[Ride]的函数。输出函数接受一个Ride对象数组，并返回一个由提供的category过滤的Ride对象数组。 在这里通过寻找适合小孩子的游乐设施来检查过滤器： 12let kidRideFilter = filter(for: .kids)print(\"some good rides for kids are:\\n\\(kidRideFilter(parkRides))\") 您应该可以在控制台输出中看到Spinning Tea Cups和Grand Carousel。 纯函数FP中的一个主要概念是纯函数，它允许您对程序结构以及测试程序结果进行推理。如果函数满足两个条件，则它是纯函数： 当给定相同的输入时，函数总是产生相同的输出，例如，输出仅取决于其输入。 函数在其外部没有副作用。 在playground中添加以下纯函数： 1234func ridesWithWaitTimeUnder(_ waitTime: Minutes, from rides: [Ride]) -&gt; [Ride] &#123; return rides.filter &#123; $0.waitTime &lt; waitTime &#125;&#125; rides withwaittimeunder（_:from:）是一个纯函数，因为当给定相同的等待时间和相同的rides列表时，它的输出总是相同的。 有了纯函数，就很容易针对该函数编写一个好的单元测试。将以下测试添加到您的playgroud： 1234567891011121314let shortWaitRides = ridesWithWaitTimeUnder(15, from: parkRides)func testShortWaitRides(_ testFilter:(Minutes, [Ride]) -&gt; [Ride]) &#123; let limit = Minutes(15) let result = testFilter(limit, parkRides) print(\"rides with wait less than 15 minutes:\\n\\(result)\") let names = result.map &#123; $0.name &#125;.sorted(by: &lt;) let expected = [\"Crazy Funhouse\", \"Mountain Railroad\"] assert(names == expected) print(\"✅ test rides with wait time under 15 = PASS\\n-\")&#125;testShortWaitRides(ridesWithWaitTimeUnder(_:from:)) 请注意你是如何将ridesWithWaitTimeUnder(_:from:)传递给测试。请记住，函数是一等公民，您可以像传递任何其他数据一样传递它们。这将在下一节派上用场。另外，运行你的测试程序再次使用map（_:）和sorted（_by:）提取名称。你在用FP测试你的FP技能。 参照透明度纯函数与参照透明的概念有关。如果一个程序的元素可以用它的定义替换它，并且总是产生相同的结果，那么它的引用是透明的。它生成可预测的代码，并允许编译器执行优化。纯函数满足这个条件。 通过将函数体传递给ridesWithWaitTimeUnder(_:from:)，可以验证函数testShortWaitRides(_:)是否具有引用透明性： 123testShortWaitRides(&#123; waitTime, rides in return rides.filter&#123; $0.waitTime &lt; waitTime &#125;&#125;) 在这段代码中，你获取了ridesWithWaitTimeUnder(_:from:)，并将其直接传递给封装在闭包语法中的testShortWaitrides（:）。这证明了ridesWithWaitTimeUnder(_:from:)是引用透明的。 在重构某些代码时,希望确保不会破坏任何东西，引用透明性是很有用。引用透明代码不仅易于测试，而且还允许您在不必验证实现的情况下移动代码。 递归最后要讨论的概念是递归。每当函数调用自身作为其函数体的一部分时，都会发生递归。在函数式语言中，递归替换了许多在命令式语言中使用的循环结构。 当函数的输入导致函数调用自身时，就有了递归情况。为了避免函数调用的无限堆栈，递归函数需要一个基本情况来结束它们。 您将为您的rides添加一个递归排序函数。首先，使用下面的拓展让Ride遵循Comparable协议： 123456789extension Ride: Comparable &#123; public static func &lt;(lhs: Ride, rhs: Ride) -&gt; Bool &#123; return lhs.waitTime &lt; rhs.waitTime &#125; public static func ==(lhs: Ride, rhs: Ride) -&gt; Bool &#123; return lhs.name == rhs.name &#125;&#125; 在这个扩展中，可以使用运算符重载来创建允许比较两个rides的函数。您还可以看到在排序之前使用的&lt;运算符的完整函数声明sorted(by:)。如果等待时间更少，那么一个ride就少于另一个ride，如果rides具有相同的名称，则rides是相等的。现在，扩展数组以包含quickSorted方法： 1234567891011extension Array where Element: Comparable &#123; func quickSorted() -&gt; [Element] &#123; if self.count &gt; 1 &#123; let (pivot, remaining) = (self[0], dropFirst()) let lhs = remaining.filter &#123; $0 &lt;= pivot &#125; let rhs = remaining.filter &#123; $0 &gt; pivot &#125; return lhs.quickSorted() + [pivot] + rhs.quickSorted() &#125; return self &#125;&#125; 此扩展允许您对数组进行排序，只要元素是可比较的。快速排序算法首先选择一个基准元素。然后将集合分成两部分。一部分包含小于或等于基准元素的所有元素，另一部分包含大于基准元素的其余元素。然后使用递归对这两部分进行排序。注意，通过使用递归，您不需要使用可变状态。 输入以下代码以验证您的方法是否正常工作： 1234567891011let quickSortedRides = parkRides.quickSorted()print(\"\\(quickSortedRides)\")func testSortedByWaitRides(_ rides: [Ride]) &#123; let expected = rides.sorted(by: &#123; $0.waitTime &lt; $1.waitTime &#125;) assert(rides == expected, \"unexpected order\") print(\"✅ test sorted by wait time = PASS\\n-\")&#125;testSortedByWaitRides(quickSortedRides) 在这里，您将检查您的解决方案是否与来自受信任的swift标准库函数的预期值匹配。请记住递归函数具有额外的内存使用和运行时开销。在数据集变得更大之前，您不必担心这些问题。 命令与声明性代码风格在本节中，您将结合您所学到的关于FP的知识来清楚地演示函数编程的好处。考虑以下情况：一个有小孩的家庭希望在频繁的浴室休息之间尽可能多地乘车。他们需要找出哪一种适合儿童乘车的路线最短。帮助他们找出所有家庭乘坐等待时间少于20分钟，并排序他们最短到最长的等待时间。 用命令式方法解决问题考虑一下如何用强制算法来解决这个问题。试着用你自己的方法解决这个问题。您的解决方案可能类似于： 12345678910var ridesOfInterest: [Ride] = []for ride in parkRides where ride.waitTime &lt; 20 &#123; for category in ride.categories where category == .family &#123; ridesOfInterest.append(ride) break &#125;&#125;let sortedRidesOfInterest1 = ridesOfInterest.quickSorted()print(sortedRidesOfInterest1) 把这个加到你的playground上并执行它。你应该看到，Mountain Railroad, Crazy Funhouse 和Grand Carousel 是最好的乘坐选择，该名单是为了增加等待时间。 正如所写的，命令式代码很好，但快速浏览并不能清楚地显示它正在做什么。你必须停下来仔细看看算法来掌握它。当您六个月后返回进行维护时，或者将代码交给新的开发人员时，代码是否容易理解？ 添加此测试以将FP方法与您的命令式解决方案进行比较： 12345678910func testSortedRidesOfInterest(_ rides: [Ride]) &#123; let names = rides.map &#123; $0.name &#125;.sorted(by: &lt;) let expected = [\"Crazy Funhouse\", \"Grand Carousel\", \"Mountain Railroad\"] assert(names == expected) print(\"✅ test rides of interest = PASS\\n-\")&#125;testSortedRidesOfInterest(sortedRidesOfInterest1) 用函数方法解决问题使用FP解决方案，您可以使代码更具自解释性。将以下代码添加到您的playground： 123let sortedRidesOfInterest2 = parkRides .filter &#123; $0.categories.contains(.family) &amp;&amp; $0.waitTime &lt; 20 &#125; .sorted(by: &lt;) 通过添加以下内容，验证这行代码是否生成与命令代码相同的输出： 1testSortedRidesOfInterest(sortedRidesOfInterest2) 在一行代码中，您告诉swift要计算什么。您希望将您的parkRides过滤到具有小于20分钟的等待时间的.family的游乐设施，然后对它们排序。这就彻底解决了上述问题。生成的代码是声明性的，这意味着它是自解释的，并且读起来就像它解决的问题陈述。这与命令式代码不同，命令式代码读起来像是计算机解决问题语句所必须采取的步骤。 函数编程的时间和原因Swift不是纯粹的函数式编程语言，但它结合了多种编程范式，为您提供了应用程序开发的灵活性。开始使用FP技术的一个好地方是在模型层和应用程序的业务逻辑出现的地方。您已经看到创建这种逻辑的离散测试是多么容易。对于用户界面，不太清楚看哪里可以使用FP编程。Reactive programming是一种用于用户界面开发的类似于FP的方法的例子。例如，RxSwift是一个用于IOS和MACOS编程的反应库。通过使用函数式，声明性方法，代码变得更加简洁明了。另外，当代码被隔离到没有副作用的模块化函数中时，它将更容易测试。当你想最大化你的多核CPU的全部潜力时，最小化并发带来的副作用和问题是很重要的。FP是一个很好的工具，在你的技能中应对那些问题。 本文涉及的全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404/// Copyright (c) 2018 Razeware LLC////// Permission is hereby granted, free of charge, to any person obtaining a copy/// of this software and associated documentation files (the \"Software\"), to deal/// in the Software without restriction, including without limitation the rights/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell/// copies of the Software, and to permit persons to whom the Software is/// furnished to do so, subject to the following conditions:////// The above copyright notice and this permission notice shall be included in/// all copies or substantial portions of the Software.////// Notwithstanding the foregoing, you may not use, copy, modify, merge, publish,/// distribute, sublicense, create a derivative work, and/or sell copies of the/// Software in any work that is designed, intended, or marketed for pedagogical or/// instructional purposes related to programming, coding, application development,/// or information technology. Permission for such use, copying, modification,/// merger, publication, distribution, sublicensing, creation of derivative works,/// or sale is expressly withheld.////// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN/// THE SOFTWARE.import Foundation//: # Introduction to Functional Programming/*: ## Imperative Style Command your data! */var thing = 3//some stuffthing = 4/*: ## Side effects Holy mysterious change! - Why is my thing now 5? */func superHero() &#123; print(\"I'm batman\") thing = 5&#125;print(\"original state = \\(thing)\")superHero()print(\"mutated state = \\(thing)\")/*: ## Create a Model */enum RideCategory: String &#123; case family case kids case thrill case scary case relaxing case water&#125;typealias Minutes = Doublestruct Ride &#123; let name: String let categories: Set&lt;RideCategory&gt; let waitTime: Minutes&#125;/*: ## Create some data using that model */let parkRides = [ Ride(name: \"Raging Rapids\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"Crazy Funhouse\", categories: [.family], waitTime: 10.0), Ride(name: \"Spinning Tea Cups\", categories: [.kids], waitTime: 15.0), Ride(name: \"Spooky Hollow\", categories: [.scary], waitTime: 30.0), Ride(name: \"Thunder Coaster\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"Grand Carousel\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"Bumper Boats\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"Mountain Railroad\", categories: [.family, .relaxing], waitTime: 0.0)]/*: ### Attempt to change immutable data. *///parkRides[0] = Ride(name: \"Functional Programming\", categories: [.thrill], waitTime: 5.0)/*: ## Modularity Create a function that does one thing. 1. Returns the names of the rides in alphabetical order. */func sortedNamesImp(of rides: [Ride]) -&gt; [String] &#123; // 1 var sortedRides = rides var key: Ride // 2 for i in (0..&lt;sortedRides.count) &#123; key = sortedRides[i] // 3 for j in stride(from: i, to: -1, by: -1) &#123; if key.name.localizedCompare(sortedRides[j].name) == .orderedAscending &#123; sortedRides.remove(at: j + 1) sortedRides.insert(key, at: j) &#125; &#125; &#125; // 4 var sortedNames: [String] = [] for ride in sortedRides &#123; sortedNames.append(ride.name) &#125; return sortedNames&#125;let sortedNames1 = sortedNamesImp(of: parkRides)//: Test your new functionfunc testSortedNames(_ names: [String]) &#123; let expected = [\"Bumper Boats\", \"Crazy Funhouse\", \"Grand Carousel\", \"Mountain Railroad\", \"Raging Rapids\", \"Spinning Tea Cups\", \"Spooky Hollow\", \"Thunder Coaster\"] assert(names == expected) print(\"✅ test sorted names = PASS\\n-\")&#125;print(sortedNames1)testSortedNames(sortedNames1)var originalNames: [String] = []for ride in parkRides &#123; originalNames.append(ride.name)&#125;//: Test that original data is untouchedfunc testOriginalNameOrder(_ names: [String]) &#123; let expected = [\"Raging Rapids\", \"Crazy Funhouse\", \"Spinning Tea Cups\", \"Spooky Hollow\", \"Thunder Coaster\", \"Grand Carousel\", \"Bumper Boats\", \"Mountain Railroad\"] assert(names == expected) print(\"✅ test original name order = PASS\\n-\")&#125;print(originalNames)testOriginalNameOrder(originalNames)/*: ## First class and higher order functions. Most languages that support FP will have the functions `filter`, `map` &amp; `reduce`. ### Filter Filter takes the input `Collection` and filters it according to the function you provide. Here's a simple example. */let apples = [\"🍎\", \"🍏\", \"🍎\", \"🍏\", \"🍏\"]let greenapples = apples.filter &#123; $0 == \"🍏\"&#125;print(greenapples)//: Next, try filtering your ride datafunc waitTimeIsShort(_ ride: Ride) -&gt; Bool &#123; return ride.waitTime &lt; 15.0&#125;let shortWaitTimeRides = parkRides.filter(waitTimeIsShort)print(\"rides with a short wait time:\\n\\(shortWaitTimeRides)\")let shortWaitTimeRides2 = parkRides.filter &#123; $0.waitTime &lt; 15.0 &#125;print(shortWaitTimeRides2)/*: ### Minor detour: CustomStringConvertible You want to make your console output look nice. */extension RideCategory: CustomStringConvertible &#123; var description: String &#123; return rawValue &#125;&#125;extension Ride: CustomStringConvertible &#123; var description: String &#123; return \"Ride –\\\"\\(name)\\\", wait: \\(waitTime) mins, categories: \\(categories)\\n\" &#125;&#125;/*: ### Map Map converts each `Element` in the input `Collection` into a new thing based on the function that you provide. First create oranges from apples. */let oranges = apples.map &#123; _ in \"🍊\" &#125;print(oranges)//: Now extract the names of your rideslet rideNames = parkRides.map &#123; $0.name &#125;print(rideNames)testOriginalNameOrder(rideNames)print(rideNames.sorted(by: &lt;))func sortedNamesFP(_ rides: [Ride]) -&gt; [String] &#123; let rideNames = parkRides.map &#123; $0.name &#125; return rideNames.sorted(by: &lt;)&#125;let sortedNames2 = sortedNamesFP(parkRides)testSortedNames(sortedNames2)/*: ### Reduce Reduce iterates across the input `Collection` to reduce it to a single value. You can squish your oranges into one juicy string. */let juice = oranges.reduce(\"\")&#123;juice, orange in juice + \"🍹\"&#125;print(\"fresh 🍊 juice is served – \\(juice)\")//: Here you **reduce** the collection to a single value of type `Minutes` (a.k.a `Double`)let totalWaitTime = parkRides.reduce(0.0) &#123; (total, ride) in total + ride.waitTime&#125;print(\"total wait time for all rides = \\(totalWaitTime) minutes\")/*: ## Partial Functions A function can return a function. `filter(for:)` returns a function of type `([Ride]) -&gt; ([Ride])` it takes and returns an array of `Ride` objects */func filter(for category: RideCategory) -&gt; ([Ride]) -&gt; [Ride] &#123; return &#123; (rides: [Ride]) in rides.filter &#123; $0.categories.contains(category) &#125; &#125;&#125;//: you can use it to filter the list for all rides that are suitable for kids.let kidRideFilter = filter(for: .kids)print(\"some good rides for kids are:\\n\\(kidRideFilter(parkRides))\")/*: ## Pure Functions - Always give same output for same input - Have no side effects */func ridesWithWaitTimeUnder(_ waitTime: Minutes, from rides: [Ride]) -&gt; [Ride] &#123; return rides.filter &#123; $0.waitTime &lt; waitTime &#125;&#125;let shortWaitRides = ridesWithWaitTimeUnder(15, from: parkRides)func testShortWaitRides(_ testFilter:(Minutes, [Ride]) -&gt; [Ride]) &#123; let limit = Minutes(15) let result = testFilter(limit, parkRides) print(\"rides with wait less than 15 minutes:\\n\\(result)\") let names = result.map&#123; $0.name &#125;.sorted(by: &lt;) let expected = [\"Crazy Funhouse\", \"Mountain Railroad\"] assert(names == expected) print(\"✅ test rides with wait time under 15 = PASS\\n-\")&#125;testShortWaitRides(ridesWithWaitTimeUnder(_:from:))//: when you replace the function with its body, you expect the same resulttestShortWaitRides(&#123; waitTime, rides in rides.filter&#123; $0.waitTime &lt; waitTime &#125;&#125;)/*: ## Recursion Recursion is when a function calls itself as part of its function body. Make `Ride` conform to `Comparable` so you can compare two `Ride` objects: */extension Ride: Comparable &#123; static func &lt;(lhs: Ride, rhs: Ride) -&gt; Bool &#123; return lhs.waitTime &lt; rhs.waitTime &#125; static func ==(lhs: Ride, rhs: Ride) -&gt; Bool &#123; return lhs.name == rhs.name &#125;&#125;/*: Next add a `quickSorted` algorithim to `Array` */extension Array where Element: Comparable &#123; func quickSorted() -&gt; [Element] &#123; if self.count &gt; 1 &#123; let (pivot, remaining) = (self[0], dropFirst()) let lhs = remaining.filter &#123; $0 &lt;= pivot &#125; let rhs = remaining.filter &#123; $0 &gt; pivot &#125; return lhs.quickSorted() + [pivot] + rhs.quickSorted() &#125; return self &#125;&#125;//: test your algorithmlet quickSortedRides = parkRides.quickSorted()print(\"\\(quickSortedRides)\")/*: check that your solution matches the expected value from the standard library function */func testSortedByWaitRides(_ rides: [Ride]) &#123; let expected = rides.sorted(by: &#123; $0.waitTime &lt; $1.waitTime &#125;) assert(rides == expected, \"unexpected order\") print(\"✅ test sorted by wait time = PASS\\n-\")&#125;testSortedByWaitRides(quickSortedRides)/*: ## Imperative vs Declarative style ### Imperitive style. Fill a container with the right things. */var ridesOfInterest: [Ride] = []for ride in parkRides where ride.waitTime &lt; 20 &#123; for category in ride.categories where category == .family &#123; ridesOfInterest.append(ride) break &#125;&#125;let sortedRidesOfInterest1 = ridesOfInterest.quickSorted()print(sortedRidesOfInterest1)func testSortedRidesOfInterest(_ rides: [Ride]) &#123; let names = rides.map(&#123; $0.name &#125;).sorted(by: &lt;) let expected = [\"Crazy Funhouse\", \"Grand Carousel\", \"Mountain Railroad\"] assert(names == expected) print(\"✅ test rides of interest = PASS\\n-\")&#125;testSortedRidesOfInterest(sortedRidesOfInterest1)/*: ### Functional Approach Declare what you're doing. Filter, Sort, Profit :] */let sortedRidesOfInterest2 = parkRides .filter &#123; $0.categories.contains(.family) &amp;&amp; $0.waitTime &lt; 20 &#125; .sorted(by: &lt;)testSortedRidesOfInterest(sortedRidesOfInterest2)","categories":[],"tags":[]},{"title":"【译】如何在swift中使用函数式编程","slug":"swift-operator-override","date":"2019-08-28T07:50:28.000Z","updated":"2022-05-02T05:51:49.850Z","comments":true,"path":"2019/08/28/swift-operator-override/","link":"","permalink":"https://github.com/Esdeath/Esdeath.github.io/2019/08/28/swift-operator-override/","excerpt":"","text":"原文链接：https://www.raywenderlich.com/4018226-overloading-custom-operators-in-swift swift重载自定义运算符 在本Swift教程中，您将学习如何创建自定义运算符，重载现有运算符以及设置运算符优先级。 运算符是任何编程语言的核心构建模块。 你能想象编程而不使用+或=吗？ 运算符非常基础，大多数语言都将它们作为编译器（或解释器）的一部分进行处理。 但是Swift编译器并不对大多数操作符进行硬编码，而是为库提供了创建的操作符的方法。 它将工作留给了Swift标准库，用来提供您期望的所有常见操作符。 这种微妙的差异为巨大的定制潜力打开了大门。 Swift运算符特别强大，因为您可以通过两种方式更改它们以满足您的需求：为现有运算符分配新功能（称为运算符重载），以及创建新的自定义运算符。 在本教程中，您将使用一个简单的Vector结构并构建自己的一组运算符，以组合不同的向量。 入门打开Xcode，然后通过File▶New▶Playground创建一个Playground。 选择空白模板并命名您的Playground为CustomOperators。 删除所有默认代码，以便您可以从空白平板开始。 将以下代码添加到您的Playground： 1234567891011121314151617181920struct Vector &#123; let x: Int let y: Int let z: Int&#125;extension Vector: ExpressibleByArrayLiteral &#123; init(arrayLiteral: Int...) &#123; assert(arrayLiteral.count == 3, \"Must initialize vector with 3 values.\") self.x = arrayLiteral[0] self.y = arrayLiteral[1] self.z = arrayLiteral[2] &#125;&#125;extension Vector: CustomStringConvertible &#123; var description: String &#123; return \"(\\(x), \\(y), \\(z))\" &#125;&#125; 在这里，您可以定义一个含有三个属性的Vector类型，它遵循两个协议。 CustomStringConvertible协议和description计算属性允许您打印一个友好的字符串用来代表Vector。 在playground的底部，添加以下代码： 12let vectorA: Vector = [1, 3, 2]let vectorB = [-2, 5, 1] as Vector 在没有初始化器的情况下,你刚刚用了两个Array来创建两个Vector!那是如何发生的呢?ExpressibleByArrayLiteral协议提供了一个平滑的接口来初始化Vector。该协议需要一个具有可变参数的不可用初始化程序：init（arrayLiteral：Int ...） 可变参数arrayLiteral允许您传入由逗号分隔的无限数量的值。例如，您可以创建Vector，像这样Vector(arrayLiteral：0）或Vector（arrayLiteral：5,4,3）。 该协议进一步方便，并允许您直接使用数组进行初始化，只要您明确定义类型，这是您为vectorA和vectorB所做的。 这种方法的唯一警告是你必须接受任何长度的数组。如果您将此代码放入应用程序中，请记住，如果传入长度不是三的数组，它将会崩溃。如果您尝试初始化少于或多于三个值的Vector，则初始化程序顶部的断言将在开发和内部测试期间在控制台中提醒您。 单独的矢量很好，但如果你能用它们做事情会更好。正如你在学校时所做的那样，你将开始你学习 加法 之旅。 重载加法运算符运算符重载的一个简单示例是加法运算符。 如果您将它与两个数字一起使用，则会发生以下情况： 11 + 1 // 2 但是，如果对字符串使用相同的加法运算符，则它具有完全不同的行为： 1\"1\" + \"1\" // \"11\" 当+与两个整数一起使用时，它会以算术形式把它们相加。 但是当它与两个字符串一起使用时，它会将它们连接起来。 为了使运算符重载，您必须实现一个名称为运算符符号的函数。 注意： 您可以将重载函数定义为类方法，这是您将在本教程中执行的操作。 这样做时，必须将其声明为static函数，以便可以在没有定义它的实例的情况下访问它。 在playground最后面添加如下代码: 12345678910// MARK: - Operatorsextension Vector &#123; static func + (left: Vector, right: Vector) -&gt; Vector &#123; return [ left.x + right.x, left.y + right.y, left.z + right.z ] &#125;&#125; 此函数将两个向量作为参数，并将它们的和作为新向量返回。 为了让向量相加，只需组成向量的变量相加. 要测试此功能，请将以下内容添加到playground的底部： 1vectorA + vectorB // (-1, 8, 3) 您可以在playground的右侧边栏中看到向量相加的结果. 其他类型的运算符加法运算符是所谓的infx运算符，意味着它在两个不同的值之间使用。还有其他类型的运算符： infix：在两个值之间使用，例如加法运算符（例如，1 + 1） prefix：在值之前添加，如负号运算符（例如-3）。 postfix：在值之后添加，比如强制解包运算符（例如，mayBeNil！） ternary：在三个值之间插入两个符号。 在Swift中，不支持用户自定义的三元运算符，只有一个内置的三元运算符，您可以在Apple的文档中阅读。您要重载的下一个运算符是负号，它将更改Vector的每个变量的符号。 例如，如果将它应用于vectorA，即（1,3,2），则返回（-1，-3，-2）。 在这个extension中的前面一个static函数下面添加如下代码: 123static prefix func - (vector: Vector) -&gt; Vector &#123; return [-vector.x, -vector.y, -vector.z]&#125; 运算符默认是infix类型，如果您希望运算符是其他类型，则需要在函数声明中指定运算符类型。 负号运算符不是infix类型，因此您将prefix修饰符添加到函数声明中。 在playground的底部，添加以下代码： 1-vectorA // (-1, -3, -2) 在侧栏中检查结果是否正确。 接下来是减法，我将留给你实现自己。 完成后，请检查以确保您的代码与我的代码类似。 提示：减法与加上一个负数相同。 试一试，如果您需要帮助，请查看下面的解决方案！ 123static func - (left: Vector, right: Vector) -&gt; Vector &#123; return left + -right&#125; 通过添加已下代码到playground底部,测试你的新操作符的输出: 1vectorA - vectorB // (3, -2, 1) 不同类型的参数？ 没问题！您还可以通过标量乘法将向量乘以数字。 要将向量乘以2，可以将每个分量乘以2。 你接下来就要实现这个. 您需要考虑的一件事是参数的顺序。 当你实现加法的时候，顺序无关紧要，因为两个参数都是向量。 对于标量乘法，您需要考虑Int * Vector和Vector * Int。 如果您只实现其中一种情况，Swift编译器将不会自动知道您希望它以其他顺序工作。 要实现标量乘法，请在刚刚添加的减法函数下添加以下两个函数： 123456789101112static func * (left: Int, right: Vector) -&gt; Vector &#123; return [ right.x * left, right.y * left, right.z * left ]&#125;//这里用到了上面重载的*运算static func * (left: Vector, right: Int) -&gt; Vector &#123; return right * left&#125; 为避免多次写入相同的代码，第二个函数只是将其参数转发给第一个。 在数学中，向量有另一个有趣的操作，称为叉乘。 叉乘超出了本教程的范围，但您可以在Cross product Wikipedia页面上了解有关它们的更多信息。 由于在大多数情况下不鼓励使用自定义符号（谁想在编码时打开表情符号菜单？），重复使用星号进行叉乘操作会非常方便。 与标量乘法不同，叉乘将两个向量作为参数并返回一个新向量。 添加以下代码以在刚刚添加的乘法函数之后实现叉乘： 1234567static func * (left: Vector, right: Vector) -&gt; Vector &#123; return [ left.y * right.z - left.z * right.y, left.z * right.x - left.x * right.z, left.x * right.y - left.y * right.x ]&#125; 现在，将以下计算添加到playground的底部，同时利用乘法和叉乘运算符： 1vectorA * 2 * vectorB // (-14, -10, 22) 此代码找到vectorA和2的标量乘法，然后找到该向量与vectorB的交叉乘积。 请注意，星号运算符始终从左向右，因此前面的代码与使用括号分组操作相同，如（vectorA * 2）* vectorB。 运算符协议某些协议需要实现一些运算符符。 例如，符合Equatable的类型必须实现==运算符。 类似的，符合Comparable的类型必须至少实现&lt;和==，因为Comparable继承自Equatable。 Comparable类型也可以选择实现&gt;，&gt;=和&lt;=，但这些运算符具有默认实现。 对于Vector，Comparable并没有太多意义，但Equatable有意义，因为如果它们的组件全部相等，则两个向量相等。 接下来你将实现Equatable。 去实现协议，请在playground的末尾添加以下代码： 12345extension Vector: Equatable &#123; static func == (left: Vector, right: Vector) -&gt; Bool &#123; return left.x == right.x &amp;&amp; left.y == right.y &amp;&amp; left.z == right.z &#125;&#125; 添加以下代码在palyground的底部,并且测试他的输出 1vectorA == vectorB // false 上述代码返回false因为vectorA和vectorB有不同的组件.实现Equatable协议,不仅能够检查这些类型的相等性。 您还获得了自由访问contains(_:)的矢量数组！ 创建自定义运算符请记住我们通常不鼓励使用自定义运算符. 当然该规则也有例外。 关于自定义符号的一个好的经验法则是，只有在满足以下条件时才应使用它们： 它们的含义是众所周知的，或者对阅读代码的人有意义。 它们很容易在键盘上打出来.最后一个你要实现的运算符符合这两个条件。 矢量点积运算两个向量并返回单个标量数。 您的运算符会将向量中的每个值乘以另一个向量中的对应值，然后将所有这些乘积相加。点积的符号为•，您可以使用键盘上的Option-8轻松键入。您可能会想，“我可以在本教程中对其他所有操作符执行相同的操作，对吧？” 不幸的是，你还不能那样做。 在其他情况下，您重载已存在的运算符。 对于新的自定义运算符，您需要首先创建运算符。 直接在Vector实现最下面，但在CustomStringConvertible扩展之上，添加以下声明： 1infix operator •: AdditionPrecedence 将•定义为放在两个其他值之间的运算符，并且与加法运算符+具有相同的优先级。 暂时忽略优先级，因为你会在学到它。 既然已经注册了此运算符，请在运算符扩展的末尾添加其实现，紧接在运算符*的实现的下面： 123static func • (left: Vector, right: Vector) -&gt; Int &#123; return left.x * right.x + left.y * right.y + left.z * right.z&#125; 添加下面代码到playground测试他的输出: 1vectorA • vectorB // 15 到目前为止，一切看起来都不错……或者是吗？ 在playground的底部尝试以下代码： 1vectorA • vectorB + vectorA // Error! 现在，•和+具有相同的优先级，因此编译器从左到右解析表达式。 编译器将您的代码解释为： 1(vectorA • vectorB) + vectorA 此表达式归结为Int + Vector，您尚未实现并且不打算实现。 你要如何来解决这个问题？ 优先级组(Precedence Groups)Swift中的所有运算符都属于一个优先级组，它描述了运算符的运算顺序。 还记得学习小学数学中的操作顺序吗？ 这基本上就是你在这里所要处理的。在Swift标准库中，优先顺序如下：)) 以下是关于这些运算符的一些注释，您之前可能从来没有看到过它们： 位移运算符&lt;&lt;和&gt;&gt;用于二进制计算。 您使用转换运算符is和as来确定或更改值的类型。 nil合并运算符,??为可选类型提供默认值。 如果您的自定义运算符未指定优先级，则会自动分配DefaultPrecedence。 三元运算符，？ ：，类似于if-else语句。 AssignmentPrecedence,衍生出来的=，在所有运算之后进行运算。编译器解析类型具有左关联性，所以v1 + v2 + v3 ==（v1 + v2）+ v3。 操作符按它们在表中出现的顺序进行解析。 尝试使用括号重写以下代码： 1v1 + v2 * v3 / v4 * v5 == v6 - v7 / v8 当您准备好检查数学时，请查看下面的解决方案。 1(v1 + (((v2 * v3) / v4) * v5)) == (v6 - (v7 / v8)) 在大多数情况下，您需要添加括号以使代码更易于阅读。 无论哪种方式，理解编译器评估运算符的顺序都很有用。 Dot运算符优先级你新定义的dot-product不适合任何这些类别。 它的优先级必须小于加号运算符（如前所述），但它是否真的适合CastingPrecedence或RangeFormationPrecedence？ 取而代之，您将为您的点积运算符创建自己的优先级组。 用以下内容替换•运算符的原始声明： 123456precedencegroup DotProductPrecedence &#123; lowerThan: AdditionPrecedence associativity: left&#125;infix operator •: DotProductPrecedence 在这里，您创建一个新的优先级组并将其命名为DotProductPrecedence。 您将它放在低于AdditionPrecedence的位置，因为您希望加号运算符优先。 你也可以将它设为左关联，因为你想要从左到右进行评估，就像加法和乘法中一样。 然后，将此新优先级组分配给•运算符。 注意:除了lowerThan之外，您还可以在DotProductPrecedence中指定higherThan。 如果您在单个项目中有多个自定义优先级组，这一点就变得很重要。 你之前写的代码返回了你希望的结果: 1vectorA • vectorB + vectorA // 29恭喜💐–你掌握了自定义运算符 接下来你可以做些什么你可以阅读本教程完整的代码,代码已经在最后面给出.此时，您知道如何根据需要定义Swift操作符。 在本教程中，您专注于在数学领域中使用运算符。 在实践中，您将找到更多使用运算符的方法。 在ReactiveSwift框架中可以看到自定义运算符使用的一个很好的演示。 一个例子是&lt;~用来绑定，这是响应式编程中的一个重要功能。 以下是此运算符的使用示例： 1234567let (signal, _) = Signal&lt;Int, Never&gt;.pipe()let property = MutableProperty(0)property.producer.startWithValues &#123; print(\"Property received \\($0)\")&#125;property &lt;~ signal Cartography是另一个大量使用运算符重载的框架。 AutoLayout工具重载相等和比较运算符，以使NSLayoutConstraint创建更简单： 1234567891011constrain(view1, view2) &#123; view1, view2 in view1.width == (view1.superview!.width - 50) * 0.5 view2.width == view1.width - 50 view1.height == 40 view2.height == view1.height view1.centerX == view1.superview!.centerX view2.centerX == view1.centerX view1.top &gt;= view1.superview!.top + 20 view2.top == view1.bottom + 20&#125; 此外，您始终可以参考官方文档 custom operator documentation。 有了这些新的灵感来源，您可以走出世界，通过运算符重载使代码更简单。 小心不要对自定义运算符太迷恋！：] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283extension Vector: ExpressibleByArrayLiteral &#123; init(arrayLiteral: Int...) &#123; assert(arrayLiteral.count == 3, \"Must initialize vector with 3 values.\") self.x = arrayLiteral[0] self.y = arrayLiteral[1] self.z = arrayLiteral[2] &#125;&#125;precedencegroup DotProductPrecedence &#123; lowerThan: AdditionPrecedence associativity: left&#125;infix operator •: DotProductPrecedenceextension Vector: CustomStringConvertible &#123; var description: String &#123; return \"(\\(x), \\(y), \\(z))\" &#125;&#125;let vectorA: Vector = [1, 3, 2]let vectorB: Vector = [-2, 5, 1]// MARK: - Operatorsextension Vector &#123; static func + (left: Vector, right: Vector) -&gt; Vector &#123; return [ left.x + right.x, left.y + right.y, left.z + right.z ] &#125; static prefix func - (vector: Vector) -&gt; Vector &#123; return [-vector.x, -vector.y, -vector.z] &#125; static func - (left: Vector, right: Vector) -&gt; Vector &#123; return left + -right &#125; static func * (left: Int, right: Vector) -&gt; Vector &#123; return [ right.x * left, right.y * left, right.z * left ] &#125; static func * (left: Vector, right: Int) -&gt; Vector &#123; return right * left &#125; static func * (left: Vector, right: Vector) -&gt; Vector &#123; return [ left.y * right.z - left.z * right.y, left.z * right.x - left.x * right.z, left.x * right.y - left.y * right.x ] &#125; static func • (left: Vector, right: Vector) -&gt; Int &#123; return left.x * right.x + left.y * right.y + left.z * right.z &#125;&#125;vectorA + vectorB // (-1, 8, 3)-vectorA // (-1, -3, -2)vectorA - vectorB // (3, -2, 1)extension Vector: Equatable &#123; static func == (left: Vector, right: Vector) -&gt; Bool &#123; return left.x == right.x &amp;&amp; left.y == right.y &amp;&amp; left.z == right.z &#125;&#125;vectorA == vectorB // falsevectorA • vectorB // 15vectorA • vectorB + vectorA // 29","categories":[],"tags":[]}],"categories":[],"tags":[]}